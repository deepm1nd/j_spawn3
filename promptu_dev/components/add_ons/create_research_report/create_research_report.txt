[[PROCESS_SPECIFICATION_FOR_create_research_report]]
# Process Name: create_research_report
# Add-on Version: 0.1
# Description: Guides the AI through a multi-step, potentially iterative process to generate a comprehensive research report.
# This involves analyzing provided input documents and web links, performing guided research (including following references
# to a specified depth), iteratively generating content based on desired output depth, and structuring the final report.

# Overall Process Flow:
# Phase 1: Initialization and Configuration - Parse and validate all user-provided parameters.
# Phase 2: Input Document Processing - Ingest and analyze all provided input documents and links.
# Phase 3: Research and Content Generation - Perform research and generate content for each section of the report.
# Phase 4: Report Structure Definition - Define or refine the Table of Contents for the report.
# Phase 5: Iterative Report Assembly - Assemble the generated content into a structured report, iterating based on depth.
# Phase 6: Finalization and Output - Save the final report documents.

# --- START PHASE 1: Initialization and Configuration ---
# Objective: Resolve all required parameters from the USER_CONFIG file and internal defaults.

BEGIN_PHASE_1
# --- BEGIN HANDOFF & RESUMPTION LOGIC (Conceptual) ---
# This logic should ideally run after PARAMETER_DEFINITION_BLOCK and before the main parameter resolution loop.

RESOLVE_PARAMETER_FROM_USER_CONFIG_OR_DEFAULT "COMPONENT_INSTANCE_ID" store_as "Internal_Component_Instance_ID" (default_value "[Not Set]")
IF_CONDITION "[Internal_Component_Instance_ID]" != "[Not Set]" AND "[Internal_Component_Instance_ID]" != "" THEN
    SET_INTERNAL_VARIABLE "Is_Resumable_Session" to "true"
    SET_INTERNAL_VARIABLE "My_Handoff_File_Path" as_path_join "promptu_dev/aidentity/handoff_notes/components/" "[Internal_Component_Instance_ID]_handoff.md"
    INFO "Resumable session. Handoff file: [My_Handoff_File_Path]"
    IF_FILE_EXISTS "[My_Handoff_File_Path]" THEN
        INFO "Handoff file found. Attempting to load prior state."
        # READ_FILE "[My_Handoff_File_Path]" store_as "HandoffContent"
        # PARSE_JSON_OR_STRUCTURED_TEXT "[HandoffContent]" store_as "PriorState"
        # IF "PriorState" is_valid_and_contains_resumable_data THEN
        #   LOAD_FROM_MAP "PriorState" key "last_completed_phase" store_as "Resumed_Last_Completed_Phase" (default_value 0)
        #   LOAD_FROM_MAP "PriorState" key "resolved_parameters" store_as "Resumed_Resolved_Parameters_Map"
        #   LOAD_FROM_MAP "PriorState" key "phase_2_outputs" store_as "Resumed_Phase_2_Outputs_Map"
        #   ... etc. for other critical state data ...
        #   INFO "Resumed state: Last completed phase was [Resumed_Last_Completed_Phase]."
        #   SET_INTERNAL_VARIABLE "Resumed_Session_Successfully" to "true"
        # ELSE
        #   INFO "Handoff file content invalid or no resumable data. Starting fresh."
        #   SET_INTERNAL_VARIABLE "Resumed_Last_Completed_Phase" to "0"
        # END_IF
    ELSE
        INFO "No prior handoff file found for this instance. Starting fresh."
        SET_INTERNAL_VARIABLE "Resumed_Last_Completed_Phase" to "0"
        # Create initial handoff file with current params after they are resolved.
    END_IF
ELSE
    SET_INTERNAL_VARIABLE "Is_Resumable_Session" to "false"
    INFO "Not a resumable session (no ComponentInstanceID)."
END_IF
# --- END HANDOFF & RESUMPTION LOGIC ---

# The main parameter resolution loop should now check if params were already loaded from Resumed_Resolved_Parameters_Map
# if Resumed_Session_Successfully is true.

# Each BEGIN_PHASE_X should check if Resumed_Last_Completed_Phase >= X and potentially skip.
# Each SAVE_CURRENT_STATE_TO_MEMORY "PhaseX_State" should be augmented:
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
# IF Is_Resumable_Session is true THEN
#   GATHER_ALL_RELEVANT_STATE_FOR_HANDOFF (PhaseX_State, ResolvedParams, etc.) store_as "CurrentHandoffStateMap"
#   ADD_TO_MAP "CurrentHandoffStateMap" key "last_completed_phase" value "X"
#   WRITE_STRUCTURED_DATA_TO_FILE "[My_Handoff_File_Path]" from_map "CurrentHandoffStateMap"
#   INFO "Updated component handoff note: [My_Handoff_File_Path]"
# END_IF
  INFO "Starting Phase 1: Initialization and Configuration for create_research_report."

  # Define expected parameters and their sources
  PARAMETER_DEFINITION_BLOCK PARAMS_TO_RESOLVE
    # ParameterName | SourceType (USER_CONFIG or INTERNAL_DEFAULT) | DefaultValue (if SourceType is INTERNAL_DEFAULT) | IsRequired (true/false) | ValidationType
    RESEARCH_INPUT | USER_CONFIG | "[User prompt/topic or path/URL]" | true | NON_EMPTY_STRING_OR_PATH_URL # Agentiq ensures non-empty
    OUTPUT_MODE | USER_CONFIG | "SME" | true | ENUM(SME,Report)
    TARGET_SME_DOMAIN_NAME | USER_CONFIG | "[SME Domain Name]" | false | NON_EMPTY_STRING # Required if OUTPUT_MODE is SME
    REPORT_IDENTIFIER | USER_CONFIG | "[Report Identifier]" | false | NON_EMPTY_STRING # Required if OUTPUT_MODE is Report
    REQUESTED_RESEARCH_LEVEL | USER_CONFIG | "0" | true | INTEGER_RANGE(0,3)
    REFERENCE_FOLLOWING_DEPTH | USER_CONFIG | "1" | true | INTEGER_RANGE(0,2)
    TARGETED_REFERENCE_SOURCES | USER_CONFIG | "[N/A]" | false | NONE
    PROPOSED_TABLE_OF_CONTENTS | USER_CONFIG | "[No Table of Contents Provided]" | false | NONE
    GENERAL_INPUT_DOCS | USER_CONFIG | "[No general input documents provided]" | false | PATH_LIST_EXISTS_OR_URL_LIST
    GUIDELINES_DOC_PATHS | USER_CONFIG | "[No Guidelines Provided]" | false | PATH_LIST_EXISTS_OR_URL_LIST
    ADDITIONAL_WEB_LINKS_FILE | USER_CONFIG | "[No Additional Web Links File Provided]" | false | PATH_EXISTS_OR_URL
    EXEMPLAR_DOCS | USER_CONFIG | "[No Exemplar Documents Provided]" | false | PATH_LIST_EXISTS_OR_URL_LIST
    PREVIOUS_ITERATION_OUTPUT_PATH | USER_CONFIG | "[Path to previous iteration state or N/A]" | false | PATH_EXISTS_OR_PLACEHOLDER_OR_NA
  END_PARAMETER_DEFINITION_BLOCK

  # Resolve parameters using the standard loop
  AI_TASK_REPEATING_SUB_PROCESS "Resolve Configuration Parameters"
    INITIAL_STATE_FROM_SYSTEM_MEMORY "UNRESOLVED_PARAMS_LIST" from PARAMS_TO_RESOLVE # List of parameter names
    ACTION_PER_ITEM "Resolve Parameter [ITEM_NAME]"
      # Check if parameter is already resolved from a previous run (e.g., in iterative mode)
      IF_SYSTEM_MEMORY_CONTAINS "ResolvedParam_[ITEM_NAME]" THEN
        SET_INTERNAL_VARIABLE "[ITEM_NAME]" from "ResolvedParam_[ITEM_NAME]"
        INFO "Parameter [ITEM_NAME] already resolved to: [GET_INTERNAL_VARIABLE [ITEM_NAME]]"
        CONTINUE_LOOP
      END_IF

      # Get definition for current parameter
      GET_PARAMETER_DEFINITION "[ITEM_NAME]" from PARAMS_TO_RESOLVE
      # Returns: ParamName, SourceType, DefaultValue, IsRequired, ValidationType

      IF "[ParamSourceType]" == "USER_CONFIG" THEN
        # Attempt to get value from [[USER_CONFIG_FOR_create_research_report]]
        GET_USER_CONFIG_VALUE "[ParamName]" from "[[USER_CONFIG_FOR_create_research_report]]" store_as "UserValue"
        IF "[UserValue]" != "[ParamDefaultValue]" AND "[UserValue]" != "" THEN # User has provided a value
          VALIDATE_PARAMETER "[UserValue]" against "[ParamValidationType]" store_as "ValidationResult"
          IF "[ValidationResult]" == "VALID" THEN
            SET_INTERNAL_VARIABLE "[ParamName]" to "[UserValue]"
            INFO "Parameter [ParamName] resolved from USER_CONFIG to: [UserValue]"
          ELSE
            IF "[ParamIsRequired]" == "true" THEN
              FAIL_PROCESS "Required parameter [ParamName] ([UserValue]) failed validation: [ValidationResult]."
            ELSE
              SET_INTERNAL_VARIABLE "[ParamName]" to "[ParamDefaultValue]"
              INFO "Optional parameter [ParamName] ([UserValue]) failed validation. Using default: [ParamDefaultValue]."
            END_IF
          END_IF
        ELSE # User has not provided a value or it's the default placeholder
          IF "[ParamIsRequired]" == "true" THEN
            # Specific check for conditionally required PREVIOUS_ITERATION_OUTPUT_PATH
            IF "[ParamName]" == "PREVIOUS_ITERATION_OUTPUT_PATH" THEN
              GET_INTERNAL_VARIABLE "ITERATIVE_OUTPUT_DEPTH" store_as "Internal_ITERATIVE_OUTPUT_DEPTH"
              IF_CONDITION "[Internal_ITERATIVE_OUTPUT_DEPTH]" > "0" THEN
                 FAIL_PROCESS "Required parameter [ParamName] not provided and ITERATIVE_OUTPUT_DEPTH > 0."
              ELSE
                 SET_INTERNAL_VARIABLE "[ParamName]" to "[ParamDefaultValue]"
                 INFO "Parameter [ParamName] not provided by user, but not required as ITERATIVE_OUTPUT_DEPTH is 0. Using default: [ParamDefaultValue]."
              END_IF
            ELSE
              FAIL_PROCESS "Required parameter [ParamName] not provided by user."
            END_IF
          ELSE
            SET_INTERNAL_VARIABLE "[ParamName]" to "[ParamDefaultValue]"
            INFO "Optional parameter [ParamName] not provided by user. Using default: [ParamDefaultValue]."
          END_IF
        END_IF
      ELSE IF "[ParamSourceType]" == "INTERNAL_DEFAULT" THEN
        SET_INTERNAL_VARIABLE "[ParamName]" to "[ParamDefaultValue]"
        INFO "Parameter [ParamName] resolved from INTERNAL_DEFAULT to: [ParamDefaultValue]"
      END_IF
      ADD_TO_SYSTEM_MEMORY "ResolvedParam_[ITEM_NAME]" with_value "[GET_INTERNAL_VARIABLE [ParamName]]"
    END_ACTION_PER_ITEM
    TERMINATION_CONDITION "All parameters in UNRESOLVED_PARAMS_LIST processed"
  END_AI_TASK_REPEATING_SUB_PROCESS

  # Store key configuration values from resolved parameters
  GET_INTERNAL_VARIABLE "RESEARCH_INPUT" store_as "Internal_RESEARCH_INPUT"
  GET_INTERNAL_VARIABLE "OUTPUT_MODE" store_as "Internal_OUTPUT_MODE"
  GET_INTERNAL_VARIABLE "TARGET_SME_DOMAIN_NAME" store_as "Internal_TARGET_SME_DOMAIN_NAME"
  GET_INTERNAL_VARIABLE "REPORT_IDENTIFIER" store_as "Internal_REPORT_IDENTIFIER"
  GET_INTERNAL_VARIABLE "REQUESTED_RESEARCH_LEVEL" store_as "Internal_REQUESTED_RESEARCH_LEVEL"
  GET_INTERNAL_VARIABLE "REFERENCE_FOLLOWING_DEPTH" store_as "Internal_REFERENCE_FOLLOWING_DEPTH"
  GET_INTERNAL_VARIABLE "TARGETED_REFERENCE_SOURCES" store_as "Internal_TARGETED_REFERENCE_SOURCES"
  GET_INTERNAL_VARIABLE "PROPOSED_TABLE_OF_CONTENTS" store_as "Internal_PROPOSED_TABLE_OF_CONTENTS"
  GET_INTERNAL_VARIABLE "GENERAL_INPUT_DOCS" store_as "Internal_GENERAL_INPUT_DOCS"
  GET_INTERNAL_VARIABLE "GUIDELINES_DOC_PATHS" store_as "Internal_GUIDELINES_DOC_PATHS"
  GET_INTERNAL_VARIABLE "ADDITIONAL_WEB_LINKS_FILE" store_as "Internal_ADDITIONAL_WEB_LINKS_FILE"
  GET_INTERNAL_VARIABLE "EXEMPLAR_DOCS" store_as "Internal_EXEMPLAR_DOCS"
  GET_INTERNAL_VARIABLE "PREVIOUS_ITERATION_OUTPUT_PATH" store_as "Internal_PREVIOUS_ITERATION_OUTPUT_PATH"

  # Validate required inputs based on OUTPUT_MODE and construct paths
  IF_CONDITION "[Internal_OUTPUT_MODE]" == "SME" THEN
    INFO "Operational Mode: SME Augmentation"
    IF_CONDITION "[Internal_TARGET_SME_DOMAIN_NAME]" == "[SME Domain Name]" OR "[Internal_TARGET_SME_DOMAIN_NAME]" == "" THEN
      FAIL_PROCESS "TARGET_SME_DOMAIN_NAME is required for SME output mode."
    END_IF
    # Construct SME paths (ensure no leading/trailing slashes in domain name for clean path joining)
    SET_INTERNAL_VARIABLE "KbBaseDir" to "promptu_dev/kb"
    SET_INTERNAL_VARIABLE "SmeDomainPath" as_path_join "[KbBaseDir]" "[Internal_TARGET_SME_DOMAIN_NAME]"
    STORE_IN_SYSTEM_MEMORY "Calculated_SME_Domain_Path" from "SmeDomainPath"
    INFO "Target SME Domain Path: [SmeDomainPath]"

    # Refs file path is now level-specific for SME mode
    GET_INTERNAL_VARIABLE "Internal_REQUESTED_RESEARCH_LEVEL" store_as "CurrentResearchLevelForRefsSME"
    SET_INTERNAL_VARIABLE "SmeRefsFileName" to "refs_L[CurrentResearchLevelForRefsSME].md"
    # The actual Calculated_SME_Refs_Path will be set using this logic later if SME mode is confirmed.
    # For now, just log the intended filename pattern.
    INFO "SME Refs Filename pattern will be: refs_L[CurrentResearchLevelForRefsSME].md"
     # Fallback for general refs path if not SME or if needed by Report mode directly
    SET_INTERNAL_VARIABLE "GeneralRefsPath" as_path_join "[SmeDomainPath]" "refs.md" # Default for Report or non-L0 SME for now
    STORE_IN_SYSTEM_MEMORY "Calculated_SME_Refs_Path" from "GeneralRefsPath" # Default, will be overridden by specific logic below
    INFO "Default/Report Target SME Refs File: [GeneralRefsPath]" # Log default

    # Specific SME path setting for refs
    GET_INTERNAL_VARIABLE "Internal_REQUESTED_RESEARCH_LEVEL" store_as "CurrentResearchLevelForSMEPath"
    SET_INTERNAL_VARIABLE "LevelSpecificSmeRefsFileName" to "refs_L[CurrentResearchLevelForSMEPath].md"
    SET_INTERNAL_VARIABLE "LevelSpecificSmeRefsPath" as_path_join "[SmeDomainPath]" "[LevelSpecificSmeRefsFileName]"
    STORE_IN_SYSTEM_MEMORY "Calculated_SME_Refs_Path" from "LevelSpecificSmeRefsPath" # Override with level-specific path
    INFO "Actual Target SME Refs File (level-specific): [LevelSpecificSmeRefsPath]"

  ELSE_IF_CONDITION "[Internal_OUTPUT_MODE]" == "Report" THEN
    INFO "Operational Mode: Report Generation"
    IF_CONDITION "[Internal_REPORT_IDENTIFIER]" == "[Report Identifier]" OR "[Internal_REPORT_IDENTIFIER]" == "" THEN
      FAIL_PROCESS "REPORT_IDENTIFIER is required for Report output mode."
    END_IF
    # Construct Report paths
    SET_INTERNAL_VARIABLE "ReportBaseDir" to "promptu_dev/reports"
    SET_INTERNAL_VARIABLE "ReportOutputDir" as_path_join "[ReportBaseDir]" "[Internal_REPORT_IDENTIFIER]"
    SET_INTERNAL_VARIABLE "ReportBaseName" to "[Internal_REPORT_IDENTIFIER]_L[Internal_REQUESTED_RESEARCH_LEVEL]"
    STORE_IN_SYSTEM_MEMORY "Calculated_Report_Output_Dir" from "ReportOutputDir"
    STORE_IN_SYSTEM_MEMORY "Calculated_Report_Base_Name" from "ReportBaseName"
    INFO "Target Report Output Directory: [ReportOutputDir]"
    INFO "Target Report Basename: [ReportBaseName]"
  ELSE
    FAIL_PROCESS "Invalid OUTPUT_MODE specified: [Internal_OUTPUT_MODE]. Must be SME or Report."
  END_IF

  # RESEARCH_INPUT validation (already marked as required with NON_EMPTY_STRING_OR_PATH_URL)
  # Validation for PREVIOUS_ITERATION_OUTPUT_PATH if REQUESTED_RESEARCH_LEVEL > 0 (similar to before)
  IF_CONDITION "[Internal_REQUESTED_RESEARCH_LEVEL]" > "0" THEN
    IF_CONDITION "[Internal_PREVIOUS_ITERATION_OUTPUT_PATH]" != "[Path to previous iteration state or N/A]" AND "[Internal_PREVIOUS_ITERATION_OUTPUT_PATH]" != "" THEN
        VALIDATE_PARAMETER "[Internal_PREVIOUS_ITERATION_OUTPUT_PATH]" against "PATH_EXISTS" store_as "PrevIterPathVal"
        IF "[PrevIterPathVal]" != "VALID" THEN
            FAIL_PROCESS "PREVIOUS_ITERATION_OUTPUT_PATH must be a valid path if provided and REQUESTED_RESEARCH_LEVEL > 0. Current value: [Internal_PREVIOUS_ITERATION_OUTPUT_PATH]"
        END_IF
        INFO "Previous iteration state path set to: [Internal_PREVIOUS_ITERATION_OUTPUT_PATH]"
    END_IF
  END_IF

  INFO "Phase 1: Initialization and Configuration COMPLETED."
  SAVE_CURRENT_STATE_TO_MEMORY "Phase1_State"
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
END_PHASE_1
# --- END PHASE 1 ---

# --- START PHASE 2: Input Document Processing ---
# Objective: Ingest, analyze, and summarize all provided input documents and links.

BEGIN_PHASE_2
  INFO "Starting Phase 2: Input Document Processing."
  LOAD_STATE_FROM_MEMORY "Phase1_State" # Ensure parameters are available

  # Create a working directory for ingested content if needed
  CREATE_DIRECTORY "[Internal_REPORT_OUTPUT_PATH]/working_temp" store_as "WorkDir"

  # Process Primary Input Document
  INFO "Processing Primary Input Document: [Internal_PRIMARY_INPUT_DOC_PATH]"
  AI_TASK_SUB_PROCESS "Analyze Primary Document"
    DESCRIPTION "Ingest and analyze the primary input document."
    INPUT_PARAM "DocumentPath" from "Internal_PRIMARY_INPUT_DOC_PATH"
    INPUT_PARAM "StoragePath" from "WorkDir"
    OUTPUT_TO_SYSTEM_MEMORY "AnalyzedPrimaryDoc" # This would contain summary, key entities, structure etc.
    # Actual processing logic:
    # 1. Read content (handle URL or local path)
    # 2. Basic NLP (summarization, keyword extraction)
    # 3. Store processed version in WorkDir
  END_AI_TASK_SUB_PROCESS
  INFO "Primary Input Document processed."

  # Process General Input Documents
  INFO "Processing General Input Documents: [Internal_GENERAL_INPUT_DOCS]"
  AI_TASK_REPEATING_SUB_PROCESS "Analyze General Documents"
    INITIAL_STATE_FROM_INTERNAL_VARIABLE "Internal_GENERAL_INPUT_DOCS" as_list_of_paths_or_urls
    ACTION_PER_ITEM "Process Document [ITEM_VALUE]"
      AI_TASK_SUB_PROCESS "Analyze Document [ITEM_VALUE]"
        DESCRIPTION "Ingest and analyze a general input document/URL."
        INPUT_PARAM "DocumentPath" from "[ITEM_VALUE]"
        INPUT_PARAM "StoragePath" from "WorkDir"
        OUTPUT_TO_SYSTEM_MEMORY "AnalyzedDoc_[ITEM_INDEX]"
      END_AI_TASK_SUB_PROCESS
    END_ACTION_PER_ITEM
    TERMINATION_CONDITION "All documents processed"
  END_AI_TASK_REPEATING_SUB_PROCESS
  INFO "General Input Documents processed."

  # Process Exemplar Documents (similar ingestion, focus on style/structure)
  IF_CONDITION "[Internal_EXEMPLAR_DOCS]" != "[No Exemplar Documents Provided]" THEN
    INFO "Processing Exemplar Documents: [Internal_EXEMPLAR_DOCS]"
    # Similar processing loop as General Input Docs, focusing on style, tone, structure.
    # Store analysis results in system memory (e.g., "AnalyzedExemplar_StyleGuide")
  END_IF

  # Process Guidelines Documents
  IF_CONDITION "[Internal_GUIDELINES_DOC_PATHS]" != "[No Guidelines Provided]" THEN
    INFO "Processing Guidelines Documents: [Internal_GUIDELINES_DOC_PATHS]"
    # Similar processing loop, focus on extracting explicit instructions.
    # Store analysis results in system memory (e.g., "ExtractedGuidelines")
  END_IF

  # Process Additional Web Links File
  IF_CONDITION "[Internal_ADDITIONAL_WEB_LINKS_FILE]" != "[No Additional Web Links File Provided]" THEN
    INFO "Processing Additional Web Links File: [Internal_ADDITIONAL_WEB_LINKS_FILE]"
    READ_FILE "[Internal_ADDITIONAL_WEB_LINKS_FILE]" store_as "WebLinksContent"
    # Parse WebLinksContent, line by line, add to a list in system memory: "AdditionalWebResearchLinks"
  END_IF

  # Process Input Reference Files
  IF_CONDITION "[Internal_INPUT_REFERENCE_FILES]" != "[Path(s) to input reference files or N/A]" AND "[Internal_INPUT_REFERENCE_FILES]" != "" THEN
    INFO "Processing Input Reference Files: [Internal_INPUT_REFERENCE_FILES]"
    CREATE_LIST "AllLoadedReferences"
    AI_TASK_REPEATING_SUB_PROCESS "Load and Parse Reference Files"
      INITIAL_STATE_FROM_INTERNAL_VARIABLE "Internal_INPUT_REFERENCE_FILES" as_list_of_paths_or_urls
      ACTION_PER_ITEM "Process Reference File [ITEM_VALUE]"
        AI_TASK_SUB_PROCESS "Parse Reference File [ITEM_VALUE]"
          DESCRIPTION "Read and parse a single reference file (e.g., *_refs.md)."
          INPUT_PARAM "RefFilePath" from "[ITEM_VALUE]"
          # This sub-process should:
          # 1. Read the file content.
          # 2. Parse each line/entry to extract ID/Tag, URL, Description.
          #    (Assuming a parsable format, e.g., Markdown list or CSV-like structure per line)
          # 3. For each parsed reference, create a structured object/map.
          # 4. Add each structured reference to a temporary list.
          OUTPUT_TO_SYSTEM_MEMORY "ParsedReferencesFromFile_[ITEM_INDEX]" # List of structured refs
        END_AI_TASK_SUB_PROCESS
        # Append to main list
        GET_FROM_SYSTEM_MEMORY "ParsedReferencesFromFile_[ITEM_INDEX]" store_as "TempRefList"
        ADD_ITEMS_TO_LIST "AllLoadedReferences" from_list "TempRefList"
      END_ACTION_PER_ITEM
      TERMINATION_CONDITION "All reference files processed"
    END_AI_TASK_REPEATING_SUB_PROCESS
    STORE_IN_SYSTEM_MEMORY "LoadedReferencesList" from_list "AllLoadedReferences"
    INFO "Input Reference Files processed. Total references loaded: [COUNT_LIST_ITEMS [AllLoadedReferences]]"

    # Filter/Prioritize Specific References
    IF_CONDITION "[Internal_SPECIFIC_REFERENCE_IDENTIFIERS]" != "[Specify reference IDs/tags or N/A]" AND "[Internal_SPECIFIC_REFERENCE_IDENTIFIERS]" != "" THEN
      INFO "Filtering references based on Specific Identifiers: [Internal_SPECIFIC_REFERENCE_IDENTIFIERS]"
      AI_TASK_SUB_PROCESS "Filter Prioritized References"
        DESCRIPTION "Filter the loaded references based on specific IDs or tags."
        INPUT_PARAM "ReferenceList" from_memory "LoadedReferencesList"
        INPUT_PARAM "Identifiers" from "Internal_SPECIFIC_REFERENCE_IDENTIFIERS" # Comma-separated list
        # This sub-process should:
        # 1. Iterate through ReferenceList.
        # 2. For each reference, check if its ID or tags match any in Identifiers.
        # 3. Create a new list of matching/prioritized references.
        OUTPUT_TO_SYSTEM_MEMORY "PrioritizedReferencesList" # List of structured prioritized refs
      END_AI_TASK_SUB_PROCESS
      INFO "References filtered. Prioritized count: [COUNT_LIST_ITEMS [GET_FROM_SYSTEM_MEMORY PrioritizedReferencesList]]"
    ELSE
      INFO "No specific reference identifiers provided. All loaded references will be available."
      # Optionally, copy LoadedReferencesList to PrioritizedReferencesList if no filter, for consistent downstream processing
      GET_FROM_SYSTEM_MEMORY "LoadedReferencesList" store_as "TempCopyRefList"
      STORE_IN_SYSTEM_MEMORY "PrioritizedReferencesList" from_list "TempCopyRefList"
    END_IF
  ELSE
    INFO "No Input Reference Files provided."
    CREATE_LIST "PrioritizedReferencesList" # Create empty list if no input files
    STORE_IN_SYSTEM_MEMORY "PrioritizedReferencesList" from_list "PrioritizedReferencesList"
    CREATE_LIST "LoadedReferencesList" # Create empty list
    STORE_IN_SYSTEM_MEMORY "LoadedReferencesList" from_list "LoadedReferencesList"
  END_IF

  # If Iterative Depth > 0, load previous iteration's output
  IF_CONDITION "[Internal_REQUESTED_RESEARCH_LEVEL]" > "0" THEN
    AI_TASK_SUB_PROCESS "Load Previous Iteration Data"
      DESCRIPTION "Load and parse L0 output (expert_L0.md) from the previous iteration if path is provided, to extract subtopics for L1+ research."
      INPUT_PARAM "PreviousOutputPath" from "Internal_PREVIOUS_ITERATION_OUTPUT_PATH"
      INPUT_PARAM "RequestedLevel" from "Internal_REQUESTED_RESEARCH_LEVEL"
      OUTPUT_TO_SYSTEM_MEMORY "UserSpecifiedSubtopicsForL[RequestedLevel]"
      OUTPUT_TO_SYSTEM_MEMORY "LoadedL0References" (optional)
      # Internal Logic for "Load Previous Iteration Data":
      # 1.
      INFO "Attempting to load L0 data from [PreviousOutputPath] for L[RequestedLevel] research."
      # 2.
      SET_INTERNAL_VARIABLE "PathToL0Expert" as_path_join "[PreviousOutputPath]" "expert_L0.md"
      # 3.
      IF_FILE_EXISTS "[PathToL0Expert]" THEN
        # a.
        READ_FILE "[PathToL0Expert]" store_as "L0ExpertContent"
        # b.
        AI_TASK_SUB_PROCESS "Parse L0 Expert Content for Subtopics"
          # i.
          DESCRIPTION "Extract subtopics from L0 expert markdown."
          # ii.
          INPUT_PARAM "MarkdownContent" from "L0ExpertContent"
          # iii. This sub-process needs to parse the "## Identified Subtopics/Facets" section and extract the list items.
          # iv.
          OUTPUT_TO_SYSTEM_MEMORY "ParsedL0SubtopicsList"
        END_AI_TASK_SUB_PROCESS
        # c.
        GET_FROM_SYSTEM_MEMORY "ParsedL0SubtopicsList" store_as "ExtractedSubtopics"
        # d.
        IF_CONDITION "[COUNT_LIST_ITEMS [ExtractedSubtopics]]" > "0" THEN
          # i.
          STORE_IN_SYSTEM_MEMORY "UserSpecifiedSubtopicsForL[RequestedLevel]" from_list "ExtractedSubtopics"
          # ii.
          INFO "Successfully loaded [COUNT_LIST_ITEMS [ExtractedSubtopics]] subtopics from [PathToL0Expert] for L[RequestedLevel] research."
        # e.
        ELSE
          # i.
          INFO "No subtopics found or extracted from [PathToL0Expert]."
        # f.
        END_IF
      # 4.
      ELSE
        # a.
        INFO "No `expert_L0.md` found at [PathToL0Expert]. Proceeding without L0 subtopics."
      # 5.
      END_IF
      # 6. (Optional: Similar logic to load `refs_L0.md` and store its content in `LoadedL0References` if needed by Phase 3 for L1+).
    END_AI_TASK_SUB_PROCESS
  END_IF

  INFO "Phase 2: Input Document Processing COMPLETED."
  SAVE_CURRENT_STATE_TO_MEMORY "Phase2_State"
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
END_PHASE_2
# --- END PHASE 2 ---

BEGIN_PHASE_3
  INFO "Starting Phase 3: Research and Content Generation (Enhanced for Leveled Protocol)."
  LOAD_STATE_FROM_MEMORY "Phase2_State" # Ensure parameters from Phase 1 & 2 are available

  # Get key parameters for this phase
  GET_INTERNAL_VARIABLE "Internal_OPERATIONAL_MODE" store_as "OpMode"
  GET_INTERNAL_VARIABLE "Internal_REQUESTED_RESEARCH_LEVEL" store_as "ResearchLevel"
  GET_INTERNAL_VARIABLE "Internal_RESEARCH_TOPIC" store_as "ResearchTopic"
  GET_INTERNAL_VARIABLE "Internal_PRIMARY_INPUT_DOC_PATH" store_as "PrimaryInputDoc"
  GET_INTERNAL_VARIABLE "Internal_PREVIOUS_ITERATION_OUTPUT_PATH" store_as "PreviousStatePath"
  GET_INTERNAL_VARIABLE "Internal_REFERENCE_FOLLOWING_DEPTH" store_as "ReferenceDepth"
  GET_FROM_SYSTEM_MEMORY "PrioritizedReferencesList" store_as "PrioritizedRefs" (optional)
  GET_FROM_SYSTEM_MEMORY "LoadedReferencesList" store_as "AllLoadedRefs" (optional)

  # Determine current research subject (topic or primary document)
  IF_CONDITION "[ResearchTopic]" != "[Specify Research Topic or provide Primary Input Doc]" AND "[ResearchTopic]" != "" THEN
    SET_INTERNAL_VARIABLE "ResearchSubject" to "[ResearchTopic]"
  ELSE
    SET_INTERNAL_VARIABLE "ResearchSubject" to "[PrimaryInputDoc]"
  END_IF
  INFO "Research Subject: [GET_INTERNAL_VARIABLE ResearchSubject]"

  # --- Leveled Research Protocol Logic ---
  IF_CONDITION "[ResearchLevel]" == "0" THEN
    # --- Level 0 Execution ---
    INFO "Executing Level 0 research for subject: [GET_INTERNAL_VARIABLE ResearchSubject]"
    AI_TASK_SUB_PROCESS "Perform Level 0 Research"
      DESCRIPTION "Perform comprehensive L0 research. This includes: generating a detailed overview summary of the main subject; identifying key sub-topics/facets; for each sub-topic, providing an initial detailed explanation and citing 1-2 key resources; and compiling a list of all key resources found. The depth should be comparable to an initial detailed exploration (e.g., a first-pass L1 report)."
      INPUT_PARAM "Subject" from "ResearchSubject"
      INPUT_PARAM "AllReferences" from_list "AllLoadedRefs" (optional)
      INPUT_PARAM "PrioritizedReferences" from_list "PrioritizedRefs" (optional)
      # This sub-process should:
      # a. Research the main `[Subject]` to produce a detailed overview. This summary should explain core concepts, importance, and primary aspects, aiming for detail similar to an introductory chapter or detailed encyclopedia entry. Synthesize from multiple reputable sources.
      # b. Based on main subject research, identify a comprehensive list of 3-7 key sub-topics/facets.
      # c. For **each** identified sub-topic: Perform focused research to provide an initial detailed explanation (defining it, core principles, relation to main subject/other subtopics) and identify 1-2 key specific resources.
      # d. Compile a consolidated list of all key overview resources (main subject) and specific resources (subtopics).
      OUTPUT_TO_SYSTEM_MEMORY "Level0_MainSubject_DetailedSummary" # String
      OUTPUT_TO_SYSTEM_MEMORY "Level0_Identified_Subtopics" # List of strings
      OUTPUT_TO_SYSTEM_MEMORY "Level0_Subtopic_Details_List" # List of Maps: [{subtopic_name: "...", detailed_explanation: "...", specific_resources_list: ["url1", "url2"]}, ...]
      OUTPUT_TO_SYSTEM_MEMORY "Level0_Key_Resources" # List of unique URLs/references - now more comprehensive
    END_AI_TASK_SUB_PROCESS

    INFO "Level 0 research complete. Preparing to pause and report."
    STORE_IN_SYSTEM_MEMORY "ResearchCurrentTopic" from "ResearchSubject"
    # SAVE_CURRENT_STATE_TO_MEMORY "ResearchPauseState_L0" # Critical: save all relevant state for resuming later
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
    # The actual mechanism for SAVE_CURRENT_STATE_TO_MEMORY needs to be robust, saving all context from Phase1, Phase2, and current Phase3 state.
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
    # For now, assume the calling application (Agentiq) will manage state if this add-on signals completion of L0.
    # This add-on will output specific variables indicating L0 completion and its findings.
    SET_INTERNAL_VARIABLE "CurrentResearchStatus" to "LEVEL_0_COMPLETE"
    STORE_IN_SYSTEM_MEMORY "CurrentResearchStatus" from "CurrentResearchStatus"
    # Phase 3 effectively ends here for a Level 0 request, further action is up to the calling process.
    INFO "Phase 3: Level 0 Research COMPLETED for this invocation. Status: LEVEL_0_COMPLETE"

  ELSE_IF_CONDITION "[ResearchLevel]" > "0" THEN
    # --- Level > 0 Execution (Deeper Dive) ---
    INFO "Executing Level [ResearchLevel] research for subject: [GET_INTERNAL_VARIABLE ResearchSubject]"
    # Attempt to load previous state if PreviousStatePath is provided and valid
    # This part requires careful design of what state is saved and loaded.
    # For simplicity in this step, we assume Phase 2 loaded any necessary previous state if path was given.
    # Or that the calling Agentiq task passes necessary context from L0 (subtopics, key_resources) if resuming.

    # Initialize aggregated content and references for this level
    CREATE_STRING "AggregatedContent_Level[ResearchLevel]"
    CREATE_LIST "AggregatedReferences_Level[ResearchLevel]"

    # Get subtopics for current research level (loaded in Phase 2)
    GET_FROM_SYSTEM_MEMORY "UserSpecifiedSubtopicsForL[ResearchLevel]" store_as "CurrentLevelSubtopics" (default_value_is_empty_list)

    IF_CONDITION "[COUNT_LIST_ITEMS [CurrentLevelSubtopics]]" == "0" THEN
      # No subtopics, research main subject directly
      INFO "No subtopics specified for L[ResearchLevel]. Researching main subject: [ResearchSubject]"
      ADD_ITEM_TO_LIST "CurrentLevelSubtopics" item "[ResearchSubject]"
    END_IF

    # Iterate through subtopics (or the main subject if no subtopics)
    AI_TASK_REPEATING_SUB_PROCESS "Iterate Research Over Subtopics for Level [ResearchLevel]"
      INITIAL_STATE_FROM_LIST "CurrentLevelSubtopics"
      ACTION_PER_ITEM "Research Subtopic: [ITEM_VALUE] (Index: [ITEM_INDEX])"
        SET_INTERNAL_VARIABLE "CurrentSubtopic" to "[ITEM_VALUE]"
        # Store CurrentSubtopic with a more accessible name for the inserted block
        SET_INTERNAL_VARIABLE "Current_Subtopic_Name" to "[ITEM_VALUE]"

        INFO "Starting deep dive for subtopic: '[Current_Subtopic_Name]' at Level [ResearchLevel]."
        SET_INTERNAL_VARIABLE "TargetContentMultiplier" to "4"

        IF_CONDITION "[ResearchLevel]" == "1" THEN
            INFO "L1 Target: Detailed explanation, examples, pros/cons for subtopic '[Current_Subtopic_Name]'. Aim for ~[TargetContentMultiplier]x content of an L0 overview for this subtopic."
            SET_INTERNAL_VARIABLE "SpecificDepthInstructions" to "For this L1 dive into '[Current_Subtopic_Name]', provide a detailed explanation of its core concepts. Illustrate with examples where appropriate. Discuss common practices, variations, and typical pros and cons. Compare and contrast information from at least two to three different sources to ensure comprehensive understanding. Utilize REFERENCE_FOLLOWING_DEPTH (recommend value of 2 for L1) to explore linked resources thoroughly. The output for this subtopic should be a comprehensive summary, significantly more detailed than a brief L0 overview entry. Actively seek out a diverse range of source types, including documentation, academic papers (if accessible via web searches), in-depth articles, and relevant discussions, to achieve the targeted content expansion and depth for '[Current_Subtopic_Name]'."
        ELSE_IF_CONDITION "[ResearchLevel]" == "2" THEN
            INFO "L2 Target: In-depth analysis, advanced concepts, comparisons for subtopic '[Current_Subtopic_Name]'. Aim for ~[TargetContentMultiplier]x content of L1 for this subtopic."
            SET_INTERNAL_VARIABLE "SpecificDepthInstructions" to "For this L2 dive into '[Current_Subtopic_Name]', build significantly upon L1-level understanding. Provide deeper analysis, explore advanced concepts, edge cases, or specialized applications. Incorporate information from more academic or in-depth sources. If applicable, include comparative analysis of different implementations or theoretical models. Aim to critically evaluate information. Utilize REFERENCE_FOLLOWING_DEPTH (recommend value of 2 or max for L2) fully. The content should demonstrate a sophisticated understanding of '[Current_Subtopic_Name]'. Actively seek out a diverse range of source types, including documentation, academic papers (if accessible via web searches), in-depth articles, and relevant discussions, to achieve the targeted content expansion and depth for '[Current_Subtopic_Name]'."
        ELSE_IF_CONDITION "[ResearchLevel]" == "3" THEN
            INFO "L3 Target: Near-exhaustive coverage, niche areas, research frontiers for subtopic '[Current_Subtopic_Name]'. Aim for ~[TargetContentMultiplier]x content of L2 for this subtopic."
            SET_INTERNAL_VARIABLE "SpecificDepthInstructions" to "For this L3 (Ludicrous depth) dive into '[Current_Subtopic_Name]', aim for near-exhaustive coverage based on discoverable web sources. This includes deep dives into niche areas, comprehensive comparisons of various approaches, identification of research frontiers or unresolved questions where possible, and synthesis of highly specialized information. Extensive use of REFERENCE_FOLLOWING_DEPTH (max value) is expected. The output should be exceptionally detailed and authoritative for '[Current_Subtopic_Name]'. Actively seek out a diverse range of source types, including documentation, academic papers (if accessible via web searches), in-depth articles, and relevant discussions, to achieve the targeted content expansion and depth for '[Current_Subtopic_Name]'."
        ELSE
            INFO "Warning: Unknown RequestedLevel '[ResearchLevel]' for deep dive. Proceeding with general deep dive instructions."
            SET_INTERNAL_VARIABLE "SpecificDepthInstructions" to "Perform a general deep dive into '[Current_Subtopic_Name]'."
        END_IF

        INFO "Performing deep dive for L[ResearchLevel] on subtopic: [CurrentSubtopic]" # Original INFO line
        AI_TASK_SUB_PROCESS "Perform Deep Dive Research (L[ResearchLevel] - Subtopic: [CurrentSubtopic])"
          DESCRIPTION "Perform deeper research on a specific subtopic, following specific depth instructions."
          INPUT_PARAM "Subject" from "CurrentSubtopic"
          INPUT_PARAM "MainResearchSubject" from "ResearchSubject"
          INPUT_PARAM "RequestedLevel" from "ResearchLevel"
          INPUT_PARAM "ReferenceFollowingDepth" from "ReferenceDepth"
          INPUT_PARAM "SpecificDepthInstructions" from "SpecificDepthInstructions" # Pass the new instructions
          INPUT_PARAM "AllReferences" from_list "AllLoadedRefs" (optional)
          INPUT_PARAM "PrioritizedReferences" from_list "PrioritizedRefs" (optional)
          # This sub-process should:
          # 1. Focus research on the current Subtopic, guided by SpecificDepthInstructions.
          # 2. Utilize PrioritizedReferences if relevant to this subtopic.
          # 3. Use ReferenceFollowingDepth to explore linked resources.
          # 4. Synthesize information to a depth appropriate for RequestedLevel and SpecificDepthInstructions.
          OUTPUT_TO_SYSTEM_MEMORY "GeneratedSubtopicContent_L[ResearchLevel]_[ITEM_INDEX]"
          OUTPUT_TO_SYSTEM_MEMORY "DiscoveredSubtopicReferences_L[ResearchLevel]_[ITEM_INDEX]"
        END_AI_TASK_SUB_PROCESS

        # Aggregate content
        GET_FROM_SYSTEM_MEMORY "GeneratedSubtopicContent_L[ResearchLevel]_[ITEM_INDEX]" store_as "SubtopicContent"
        GET_FROM_SYSTEM_MEMORY "AggregatedContent_Level[ResearchLevel]" store_as "CurrentAggregatedContent"
        SET_INTERNAL_VARIABLE "NewAggregatedContent" to "[CurrentAggregatedContent]\n\n## Content for: [CurrentSubtopic]\n\n[SubtopicContent]"
        STORE_IN_SYSTEM_MEMORY "AggregatedContent_Level[ResearchLevel]" from "NewAggregatedContent"

        # Aggregate references
        GET_FROM_SYSTEM_MEMORY "DiscoveredSubtopicReferences_L[ResearchLevel]_[ITEM_INDEX]" store_as "SubtopicRefsList"
        GET_FROM_SYSTEM_MEMORY "AggregatedReferences_Level[ResearchLevel]" store_as "CurrentAggregatedRefsList"
        ADD_ITEMS_TO_LIST "CurrentAggregatedRefsList" from_list "SubtopicRefsList"
        STORE_IN_SYSTEM_MEMORY "AggregatedReferences_Level[ResearchLevel]" from_list "CurrentAggregatedRefsList"
      END_ACTION_PER_ITEM
      TERMINATION_CONDITION "All subtopics in CurrentLevelSubtopics processed"
    END_AI_TASK_REPEATING_SUB_PROCESS

    # Content Structuring based on Operational Mode using aggregated results
    GET_FROM_SYSTEM_MEMORY "AggregatedContent_Level[ResearchLevel]" store_as "FinalAggregatedContent"
    GET_FROM_SYSTEM_MEMORY "AggregatedReferences_Level[ResearchLevel]" store_as "FinalAggregatedRefsList"

    IF_CONDITION "[OpMode]" == "SME_AUGMENTATION" THEN
      INFO "Structuring aggregated content for SME Augmentation mode."
      STORE_IN_SYSTEM_MEMORY "FinalizedOutputContent" from "FinalAggregatedContent"
      STORE_IN_SYSTEM_MEMORY "FinalizedOutputReferences" from_list "FinalAggregatedRefsList"
    ELSE_IF_CONDITION "[OpMode]" == "REPORT_GENERATION" THEN
      INFO "Structuring aggregated content for Report Generation mode."
      # For reports, if ToC was based on L0 subtopics, this aggregated content should align.
      # If ToC is arbitrary, the aggregated content might need manual mapping or be presented as a whole.
      # Current logic stores content against specific ToC headings.
      # This part might need more sophisticated logic to map aggregated subtopic content to ToC headings if they differ.
      # For now, store the aggregated content as the main body for the overall ResearchSubject.
      # Individual subtopic content is still in memory if needed for finer-grained mapping based on ToC.
      STORE_IN_SYSTEM_MEMORY "GeneratedContent_[GET_INTERNAL_VARIABLE ResearchSubject]" from "FinalAggregatedContent"
      STORE_IN_SYSTEM_MEMORY "FinalizedOutputReferences" from_list "FinalAggregatedRefsList"
      STORE_IN_SYSTEM_MEMORY "FinalizedOutputContent" from "FinalAggregatedContent" # Fallback for simple report
      INFO "NOTE: For Report mode, aggregated subtopic content stored under main ResearchSubject. Manual ToC alignment might be needed if ToC differs from subtopics."
    END_IF
    INFO "Phase 3: Level [ResearchLevel] Research and Content Generation COMPLETED."
  ELSE
    FAIL_PROCESS "Invalid REQUESTED_RESEARCH_LEVEL: [ResearchLevel]. Must be 0 or greater."
  END_IF

  SAVE_CURRENT_STATE_TO_MEMORY "Phase3_State"
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
END_PHASE_3
# --- END PHASE 3 ---

BEGIN_PHASE_4
  INFO "Starting Phase 4: Report/Output Structure Definition."
  LOAD_STATE_FROM_MEMORY "Phase3_State"

  GET_INTERNAL_VARIABLE "Internal_OPERATIONAL_MODE" store_as "OpMode"

  IF_CONDITION "[OpMode]" == "SME_AUGMENTATION" THEN
    INFO "Operational Mode: SME Augmentation. Report ToC structure is less critical."
    # Content for SME files is assumed to be generated based on ResearchTopic and Subtopics from Phase 3.
    # We might store identified subtopics from Level 0 as a potential structure guide.
    IF_SYSTEM_MEMORY_CONTAINS "Level0_Identified_Subtopics" THEN
      GET_FROM_SYSTEM_MEMORY "Level0_Identified_Subtopics" store_as "SME_Potential_Sections"
      STORE_IN_SYSTEM_MEMORY "SME_Structure_Guidance" from_list "SME_Potential_Sections"
      INFO "Potential SME sections based on Level 0 subtopics: [GET_LIST_AS_STRING [SME_Potential_Sections]]"
    ELSE
      CREATE_LIST "EmptyGuidance"
      STORE_IN_SYSTEM_MEMORY "SME_Structure_Guidance" from_list "EmptyGuidance"
      INFO "No specific Level 0 subtopics found to guide SME structure; will rely on main topic."
    END_IF
    # Ensure FinalToC is an empty list or a marker for SME mode to avoid issues in Phase 5 if it expects a list.
    CREATE_LIST "SME_Mode_ToC_Placeholder"
    STORE_IN_SYSTEM_MEMORY "FinalToC" from_list "SME_Mode_ToC_Placeholder"
  ELSE_IF_CONDITION "[OpMode]" == "REPORT_GENERATION" THEN
    INFO "Operational Mode: Report Generation. Defining report structure."
    # Original logic for ToC generation / parsing for reports
    GET_INTERNAL_VARIABLE "Internal_PROPOSED_TABLE_OF_CONTENTS" store_as "ProposedToCInput"
    IF_CONDITION "[ProposedToCInput]" == "[No Table of Contents Provided]" THEN
      INFO "No proposed Table of Contents. Attempting to derive from research or primary input."
      # Option 1: Use Level0_Identified_Subtopics if available from Phase 3
      IF_SYSTEM_MEMORY_CONTAINS "Level0_Identified_Subtopics" THEN
        GET_FROM_SYSTEM_MEMORY "Level0_Identified_Subtopics" store_as "DerivedToCList"
        STORE_IN_SYSTEM_MEMORY "FinalToC" from_list "DerivedToCList"
        INFO "Using Level 0 identified subtopics as ToC: [GET_LIST_AS_STRING [DerivedToCList]]"
      ELSE_IF_SYSTEM_MEMORY_CONTAINS "AnalyzedPrimaryDoc.Structure" THEN # Assuming Phase 2 stores this for primary doc
        GET_FROM_SYSTEM_MEMORY "AnalyzedPrimaryDoc.Structure" store_as "PrimaryDocToCList"
        STORE_IN_SYSTEM_MEMORY "FinalToC" from_list "PrimaryDocToCList"
        INFO "Using primary document structure as ToC."
      ELSE
        # Fallback: Create a simple ToC based on the ResearchSubject
        GET_INTERNAL_VARIABLE "ResearchSubject" store_as "SubjectForToC"
        CREATE_LIST "FallbackToC" item_1 "Introduction to [SubjectForToC]" item_2 "Key Findings for [SubjectForToC]" item_3 "Conclusion for [SubjectForToC]"
        STORE_IN_SYSTEM_MEMORY "FinalToC" from_list "FallbackToC"
        INFO "Generated fallback ToC based on Research Subject."
      END_IF
    ELSE
      # Parse user-provided ToC (from file or inline)
      AI_TASK_SUB_PROCESS "Parse Proposed ToC"
        DESCRIPTION "Parse the user-provided Table of Contents."
        INPUT_PARAM "ProposedToCInput" from "ProposedToCInput"
        OUTPUT_TO_SYSTEM_MEMORY "ParsedToCList" # e.g., a list of headings
      END_AI_TASK_SUB_PROCESS
      GET_FROM_SYSTEM_MEMORY "ParsedToCList" store_as "UserToC"
      STORE_IN_SYSTEM_MEMORY "FinalToC" from_list "UserToC"
      INFO "Using user-provided ToC."
    END_IF

    GET_FROM_SYSTEM_MEMORY "FinalToC" store_as "CurrentToC"
    # Optional: AI reviews the generated content previews and ToC for coherence and completeness (as in original)
    # For simplicity, this review step is omitted in this refactoring pass.
    INFO "Report structure confirmed with [COUNT_LIST_ITEMS [CurrentToC]] sections: [GET_LIST_AS_STRING [CurrentToC]]"
  END_IF

  INFO "Phase 4: Report/Output Structure Definition COMPLETED."
  SAVE_CURRENT_STATE_TO_MEMORY "Phase4_State"
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
END_PHASE_4
# --- END PHASE 4 ---

BEGIN_PHASE_5
  INFO "Starting Phase 5: Content Assembly."
  LOAD_STATE_FROM_MEMORY "Phase4_State"

  GET_INTERNAL_VARIABLE "Internal_OPERATIONAL_MODE" store_as "OpMode"
  GET_INTERNAL_VARIABLE "Internal_REPORT_BASENAME" store_as "BaseName"
  GET_INTERNAL_VARIABLE "Internal_REQUESTED_RESEARCH_LEVEL" store_as "ResearchLevel"

  IF_CONDITION "[OpMode]" == "SME_AUGMENTATION" THEN
    INFO "Operational Mode: SME Augmentation. Preparing content for SME files."
    # Content for SME expert file is now the aggregated content from Phase 3
    GET_FROM_SYSTEM_MEMORY "FinalizedOutputContent" store_as "SME_Expert_Content_For_Append" # This is already aggregated if L1+
    STORE_IN_SYSTEM_MEMORY "SME_Expert_Content_For_Append" from "SME_Expert_Content_For_Append"
    INFO "SME expert content (potentially aggregated from subtopics) prepared for appending."

    # References for SME refs file are also the aggregated list from Phase 3
    GET_FROM_SYSTEM_MEMORY "FinalizedOutputReferences" store_as "SME_Refs_List_For_Append" # This is already aggregated if L1+
    STORE_IN_SYSTEM_MEMORY "SME_Refs_List_For_Append" from_list "SME_Refs_List_For_Append"
    INFO "SME references list (potentially aggregated from subtopics) prepared for appending. Count: [COUNT_LIST_ITEMS [SME_Refs_List_For_Append]]"

  ELSE_IF_CONDITION "[OpMode]" == "REPORT_GENERATION" THEN
    INFO "Operational Mode: Report Generation. Assembling report."
    GET_FROM_SYSTEM_MEMORY "FinalToC" store_as "ReportToC"
    SET_INTERNAL_VARIABLE "ReportFileName" to "[BaseName]_L[ResearchLevel].md"
    INFO "Assembling report: [ReportFileName]"

    CREATE_FILE_CONTENT "AssembledReport"
    APPEND_TO_CONTENT "AssembledReport" "# Research Report: [BaseName] - Level [ResearchLevel]\n\n" # Added Level to title
    GET_INTERNAL_VARIABLE "ResearchSubject" store_as "MainReportSubject"
    APPEND_TO_CONTENT "AssembledReport" "**Primary Subject:** [MainReportSubject]\n\n"

    # Handle ToC and Content
    IF_CONDITION "[COUNT_LIST_ITEMS [ReportToC]]" > "0" THEN
        APPEND_TO_CONTENT "AssembledReport" "## Table of Contents\n"
        LOOP_THROUGH_LIST "ReportToC" as "HeadingItem"
            SET_INTERNAL_VARIABLE "AnchorLink" from "[HeadingItem]"
            REPLACE_STRING_IN_VARIABLE "AnchorLink" with_pattern " " with_replacement "-"
            APPEND_TO_CONTENT "AssembledReport" "- [[HeadingItem]](#[GET_INTERNAL_VARIABLE AnchorLink])\n"
        END_LOOP
        APPEND_TO_CONTENT "AssembledReport" "\n---\n\n"

        LOOP_THROUGH_LIST "ReportToC" as "HeadingItem"
            APPEND_TO_CONTENT "AssembledReport" "## [HeadingItem]\n\n"
            # Try to get specific content for this heading (e.g., if heading was a subtopic)
            # This requires a naming convention like "GeneratedSubtopicContent_L[ResearchLevel]_[CleanedHeadingItem]"
            # For now, we'll use the main aggregated content if direct mapping is complex or not implemented.
            # A more advanced version would map ToC entries to specific subtopic outputs.
            GET_FROM_SYSTEM_MEMORY "GeneratedContent_[HeadingItem]" store_as "SectionContent" (default_value "")
            IF_CONDITION "[SectionContent]" == "" THEN
                # Fallback if no specific content for heading, use general aggregated content if available
                # This part assumes that if FinalToC is used, the content generation in Phase 3 might not have iterated by subtopics
                # but produced a single block of content.
                GET_FROM_SYSTEM_MEMORY "FinalizedOutputContent" store_as "SectionContent" (default_value "Content for this section is pending or was not generated based on current ToC.")
                APPEND_TO_CONTENT "AssembledReport" "[SectionContent]\n\n"
                # Clear FinalizedOutputContent after using it once for the first section to avoid repetition if ToC is simple.
                # This is a simplification; robust mapping is better.
                IF_CONDITION "[ITEM_INDEX]" == "0" THEN # Only use full aggregated content once if ToC is simple
                    STORE_IN_SYSTEM_MEMORY "FinalizedOutputContent" from ""
                END_IF
            ELSE
                 APPEND_TO_CONTENT "AssembledReport" "[SectionContent]\n\n"
            END_IF
        END_LOOP
    ELSE
        # No ToC, just append the aggregated content
        INFO "No Table of Contents defined. Appending all generated content."
        GET_FROM_SYSTEM_MEMORY "FinalizedOutputContent" store_as "MainReportContent"
        APPEND_TO_CONTENT "AssembledReport" "[MainReportContent]\n\n"
    END_IF

    # Handle bibliography/references for report
    GET_FROM_SYSTEM_MEMORY "FinalizedOutputReferences" store_as "ReportReferencesList" # This is already aggregated
    IF_CONDITION "[COUNT_LIST_ITEMS [ReportReferencesList]]" > "0" THEN
        APPEND_TO_CONTENT "AssembledReport" "\n---\n## References\n\n"
        LOOP_THROUGH_LIST "ReportReferencesList" as "RefItem"
            IF_TYPE_OF "[RefItem]" is_map THEN
                GET_MAP_VALUE "[RefItem]" key "URL" store_as "RefURL" (default_value "N/A")
                GET_MAP_VALUE "[RefItem]" key "Description" store_as "RefDesc" (default_value "[RefURL]")
                APPEND_TO_CONTENT "AssembledReport" "- **[[RefDesc]]**: [RefURL]\n"
            ELSE
                 APPEND_TO_CONTENT "AssembledReport" "- [RefItem]\n" # Assumes RefItem is a string URL
            END_IF
        END_LOOP
    END_IF
  END_CREATE_FILE_CONTENT

  STORE_IN_SYSTEM_MEMORY "AssembledReportContent" from_content "AssembledReport"
  INFO "Report content assembled in memory for [ReportFileName]."
  ELSE
    FAIL_PROCESS "Invalid Internal_OPERATIONAL_MODE: [OpMode] in Phase 5."
  END_IF

  INFO "Phase 5: Content Assembly COMPLETED."
  SAVE_CURRENT_STATE_TO_MEMORY "Phase5_State"
# MODIFICATION_NOTE: If Is_Resumable_Session, this should now also trigger writing current state (including PhaseX_State content and resolved params) to My_Handoff_File_Path.
END_PHASE_5
# --- END PHASE 5 ---

BEGIN_PHASE_6
  INFO "Starting Phase 6: Finalization and Output."
  LOAD_STATE_FROM_MEMORY "Phase5_State"

  GET_INTERNAL_VARIABLE "Internal_OPERATIONAL_MODE" store_as "OpMode"
    GET_INTERNAL_VARIABLE "Internal_REQUESTED_RESEARCH_LEVEL" store_as "CurrentResearchLevel"
    GET_INTERNAL_VARIABLE "ResearchSubject" store_as "CurrentResearchSubject" (default_value "[Internal_RESEARCH_TOPIC]") # Ensure it's set

    IF_CONDITION "[OpMode]" == "SME_AUGMENTATION" THEN
    GET_FROM_SYSTEM_MEMORY "Calculated_SME_Domain_Path" store_as "SmeDomainPath"
      IF_CONDITION "[SmeDomainPath]" == "" THEN FAIL_PROCESS "SmeDomainPath is not set." END_IF
      CREATE_DIRECTORY "[SmeDomainPath]"
      INFO "Ensured SME domain directory exists: [SmeDomainPath]"

    # Get the level-specific refs path calculated in Phase 1 (e.g., refs_L0.md, refs_L1.md)
    GET_FROM_SYSTEM_MEMORY "Calculated_SME_Refs_Path" store_as "LevelSpecificRefsPath"

    # Handle Expert File (expert_L0.md or expert_L[N].md)
    IF_CONDITION "[CurrentResearchLevel]" == "0" THEN
      INFO "Handling L0 SME expert file persistence."
      SET_INTERNAL_VARIABLE "ExpertFileName" to "expert_L0.md"
      SET_INTERNAL_VARIABLE "SmeExpertPath" as_path_join "[SmeDomainPath]" "[ExpertFileName]"
      GET_FROM_SYSTEM_MEMORY "Level0_MainSubject_DetailedSummary" store_as "Output_Level0_MainSummary"
      GET_FROM_SYSTEM_MEMORY "Level0_Subtopic_Details_List" store_as "Output_Level0_SubtopicDetailsList"

      CREATE_FILE_CONTENT "ExpertFileContent"
      APPEND_TO_CONTENT "ExpertFileContent" "# [CurrentResearchSubject] - L0 Research Findings\n\n"
      APPEND_TO_CONTENT "ExpertFileContent" "Date: $(DATE_ISO_8601)\n\n"
      APPEND_TO_CONTENT "ExpertFileContent" "## L0 Detailed Overview Summary\n[Output_Level0_MainSummary]\n\n" # Changed heading
      APPEND_TO_CONTENT "ExpertFileContent" "## Key Subtopics & Initial Explanations\n" # Changed heading
      LOOP_THROUGH_LIST "Output_Level0_SubtopicDetailsList" as "SubtopicDetail"
        GET_MAP_VALUE "[SubtopicDetail]" key "subtopic_name" store_as "SubtopicName"
        GET_MAP_VALUE "[SubtopicDetail]" key "detailed_explanation" store_as "SubtopicExplanation"
        GET_MAP_VALUE "[SubtopicDetail]" key "specific_resources_list" store_as "SubtopicResourcesList" # Ensure list type
        APPEND_TO_CONTENT "ExpertFileContent" "\n### [SubtopicName]\n"
        APPEND_TO_CONTENT "ExpertFileContent" "[SubtopicExplanation]\n"
        IF_CONDITION "[COUNT_LIST_ITEMS [SubtopicResourcesList]]" > "0" THEN
            APPEND_TO_CONTENT "ExpertFileContent" "**Key Resources for this Subtopic:**\n"
            LOOP_THROUGH_LIST "SubtopicResourcesList" as "ResURL"
                APPEND_TO_CONTENT "ExpertFileContent" "- [ResURL]\n"
            END_LOOP
        END_IF
      END_LOOP
      WRITE_FILE "[SmeExpertPath]" from_content "ExpertFileContent"
      INFO "L0 expert content saved to: [SmeExpertPath]"
      STORE_IN_SYSTEM_MEMORY "Generated_L0_Expert_File_Path" from "SmeExpertPath"
    ELSE
      # Handling L1+ SME expert file persistence
      INFO "Handling L[CurrentResearchLevel] SME expert file persistence."
      SET_INTERNAL_VARIABLE "ExpertFileName" to "expert_L[CurrentResearchLevel].md" # Consistent naming
      SET_INTERNAL_VARIABLE "SmeExpertPath" as_path_join "[SmeDomainPath]" "[ExpertFileName]"

      GET_FROM_SYSTEM_MEMORY "FinalizedOutputContent" store_as "ExpertContentToAppend"
      IF_CONDITION "[ExpertContentToAppend]" != "" THEN
        CREATE_FILE_CONTENT "ExpertFileContent" # Unified variable name
        APPEND_TO_CONTENT "ExpertFileContent" "\n\n---\n## Research Findings for: [CurrentResearchSubject] (Level [CurrentResearchLevel] - Aggregated Subtopics)\n\n"
        APPEND_TO_CONTENT "ExpertFileContent" "Date: $(DATE_ISO_8601)\n\n"
        APPEND_TO_CONTENT "ExpertFileContent" "[ExpertContentToAppend]"
        APPEND_FILE "[SmeExpertPath]" from_content "ExpertFileContent"
        INFO "Appended L[CurrentResearchLevel] expert content to: [SmeExpertPath]"
      ELSE
        INFO "No new L[CurrentResearchLevel] expert content generated to append."
      END_IF
    END_IF

    # Unified Reference File Handling for all levels (L0-L3) using LevelSpecificRefsPath
    # For L0, FinalizedOutputReferences should be Level0_Key_Resources
    # For L1+, FinalizedOutputReferences is AggregatedReferences_Level[N] from Phase 3
    IF_CONDITION "[CurrentResearchLevel]" == "0" THEN
        GET_FROM_SYSTEM_MEMORY "Level0_Key_Resources" store_as "RefsListToWrite" (default_value_is_empty_list)
    ELSE
        GET_FROM_SYSTEM_MEMORY "FinalizedOutputReferences" store_as "RefsListToWrite" (default_value_is_empty_list)
    END_IF

    IF_CONDITION "[COUNT_LIST_ITEMS [RefsListToWrite]]" > "0" THEN
      CREATE_FILE_CONTENT "LevelSpecificRefsContent"
      APPEND_TO_CONTENT "LevelSpecificRefsContent" "# References for: [CurrentResearchSubject] (Level [CurrentResearchLevel])\n\n"
      APPEND_TO_CONTENT "LevelSpecificRefsContent" "Date: $(DATE_ISO_8601)\n\n"
      LOOP_THROUGH_LIST "RefsListToWrite" as "RefItem"
        IF_TYPE_OF "[RefItem]" is_map THEN
            GET_MAP_VALUE "[RefItem]" key "URL" store_as "RefURL" (default_value "N/A")
            GET_MAP_VALUE "[RefItem]" key "Description" store_as "RefDesc" (default_value "[RefURL]")
            APPEND_TO_CONTENT "LevelSpecificRefsContent" "- **[[RefDesc]]**: [RefURL]\n"
        ELSE
            APPEND_TO_CONTENT "LevelSpecificRefsContent" "- [RefItem]\n"
        END_IF
      END_LOOP
      WRITE_FILE "[LevelSpecificRefsPath]" from_content "LevelSpecificRefsContent"
      INFO "Wrote L[CurrentResearchLevel] references to: [LevelSpecificRefsPath]"
      IF_CONDITION "[CurrentResearchLevel]" == "0" THEN # Store specific L0 path if needed elsewhere
        STORE_IN_SYSTEM_MEMORY "Generated_L0_Refs_File_Path" from "[LevelSpecificRefsPath]"
      END_IF
    ELSE
      INFO "No references found to write for L[CurrentResearchLevel] to [LevelSpecificRefsPath]."
    END_IF

  ELSE_IF_CONDITION "[OpMode]" == "REPORT_GENERATION" THEN
    INFO "Operational Mode: Report Generation. Saving report."
    GET_INTERNAL_VARIABLE "Internal_REPORT_OUTPUT_PATH" store_as "OutputPath"
    GET_INTERNAL_VARIABLE "ReportFileName" store_as "FileName" # From Phase 5 (e.g., Basename_L[Level].md)
    GET_FROM_SYSTEM_MEMORY "AssembledReportContent" store_as "FinalReportContent"

    CREATE_DIRECTORY "[OutputPath]"
    WRITE_FILE "[OutputPath]/[FileName]" with_content "[FinalReportContent]"
    INFO "Report successfully saved to: [OutputPath]/[FileName]"
  ELSE
    FAIL_PROCESS "Invalid Internal_OPERATIONAL_MODE: [OpMode] in Phase 6."
  END_IF

  # Status Reporting for Leveled Research
  IF_SYSTEM_MEMORY_CONTAINS "CurrentResearchStatus" THEN
    GET_FROM_SYSTEM_MEMORY "CurrentResearchStatus" store_as "FinalStatus"
    INFO "Final Research Status for this run: [FinalStatus]"
    IF_CONDITION "[FinalStatus]" == "LEVEL_0_COMPLETE" THEN
      # Ensure Level 0 outputs are explicitly set for the calling process to retrieve
      GET_FROM_SYSTEM_MEMORY "Level0_Summary_Text" store_as "Output_Level0_Summary" (optional)
      GET_FROM_SYSTEM_MEMORY "Level0_Identified_Subtopics" store_as "Output_Level0_Subtopics" (optional)
      GET_FROM_SYSTEM_MEMORY "Level0_Key_Resources" store_as "Output_Level0_Resources" (optional)
      STORE_IN_SYSTEM_MEMORY "Output_Level0_Summary" from "[Output_Level0_Summary]"
      STORE_IN_SYSTEM_MEMORY "Output_Level0_Subtopics" from_list "[Output_Level0_Subtopics]"
      STORE_IN_SYSTEM_MEMORY "Output_Level0_Resources" from_list "[Output_Level0_Resources]"
      INFO "Level 0 outputs prepared. Add-on run complete for this level. Awaiting further instructions for deeper levels via new invocation."
    ELSE
      INFO "Research Level [ResearchLevel] processing complete."
    END_IF
  ELSE
    INFO "Standard research processing complete (non-leveled or final level)."
  END_IF

  INFO "Phase 6: Finalization and Output COMPLETED."
  INFO "create_research_report process finished for the requested level."
END_PHASE_6
# --- END PHASE 6 ---

[[END_PROCESS_SPECIFICATION_FOR_create_research_report]]

# MODIFICATION_NOTE: At the very end of successful execution or on FAIL_PROCESS, if Is_Resumable_Session, update My_Handoff_File_Path with terminal status (Completed/Failed) and paths to final outputs/error details.
