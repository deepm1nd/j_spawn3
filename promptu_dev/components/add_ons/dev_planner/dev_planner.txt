ATTENTION PLANNING AI: Your primary function is to interpret the user's project request (provided by the user *before* the `post_promptu.txt` begins, and accessible via `User_High_Level_Project_Goal` variable from Core Instructions Section I.A) and then to follow the instructions within this `task_spawning_addon` to generate a comprehensive, phased execution plan. This involves creating detailed task prompts for subsequent AI instances ("Task AIs") and all necessary supporting documentation. Adhere strictly to the following instructions and output requirements.

**I. PARAMETER RESOLUTION FOR DEV_PLANNER:**

A.  **Acknowledge Component and Configuration Source:**
    1.  You are currently executing the `dev_planner` addon.
    2.  Your primary configuration parameters are defined in `promptu/add_ons/dev_planner/USER_dev_planner_CONFIG.txt`. This file specifies parameter names, their requirements (Required/Optional), default types (Accepted/Placeholder), descriptions, and default values.
    3.  The Core Planning Instructions (Section I.D.4.c.iii) should have already scanned the main user prompt and loaded any content from a `[[USER_CONFIG_FOR_dev_planner]]...[[END_USER_CONFIG_FOR_dev_planner]]` block into the `App_Specific_Configs_Content_Map['dev_planner']` variable. This content takes highest precedence.

B.  **Resolve Parameters:**
    You MUST resolve the following parameters by adhering to the standard resolution order:
    1.  Value from the `[[USER_CONFIG_FOR_dev_planner]]` block (passed in `App_Specific_Configs_Content_Map['dev_planner']`).
    2.  User-edited value in `USER_dev_planner_CONFIG.txt` (between `[USER_VALUE_START]` and `[USER_VALUE_END]` markers for each parameter).
    3.  The "AcceptedDefault" value specified in the comment for that parameter in `USER_dev_planner_CONFIG.txt` (e.g., `# Default: actual_default_value`).
    4.  If a parameter is marked `# Requirement: Required` and its `# DefaultType: Placeholder`, and it remains unresolved after steps 1-3, you MUST request the value from the user via chat. After receiving the value, you MUST update the on-disk `promptu/add_ons/dev_planner/USER_dev_planner_CONFIG.txt` file (specifically the value between `[USER_VALUE_START]` and `[USER_VALUE_END]`) AND advise the user to also update their main prompt's `[[USER_CONFIG_FOR_dev_planner]]` block with this new value for future consistency.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    5.  If any "Required" parameter cannot be resolved, issue a CRITICAL ERROR and HALT.
    Note: For parameters expected to be a list of paths/URLs (e.g., `PROJECT_SPECIFICATIONS_REF`, `PLAN_METHODOLOGY_GUIDES`, `PLAN_EXEMPLAR_REFS`), the resolved string value (if not empty and not a placeholder like "N/A") should be split by commas to form a list of strings. Trim whitespace from each item in the list. This list is then stored in the corresponding `Resolved_DP_...` variable. If the value is empty or a placeholder, the `Resolved_DP_...` variable should be an empty list or reflect the "N/A" status appropriately.

C.  **Internal Storage of Resolved Parameters:**
    Store the resolved values internally using clear variable names. For example:
    *   `Resolved_DP_User_Plan_Proposal_Path` (from `USER_PLAN_PROPOSAL_PATH` parameter)
    *   `Resolved_DP_Project_Name` (from `PROJECT_NAME` parameter)
    *   `Resolved_DP_Iteration_ID` (from `ITERATION_ID` parameter)
    *   `Resolved_DP_Base_Output_Path` (from `BASE_OUTPUT_PATH` parameter)
    *   `Resolved_DP_Main_Dev_Plan_Filename` (from `MAIN_DEV_PLAN_FILENAME` parameter)
    *   `Resolved_DP_Task_Prompts_Subdir` (from `TASK_PROMPTS_SUBDIR` parameter)
    *   `Resolved_DP_Submodule_Plans_Subdir` (from `SUBMODULE_PLANS_SUBDIR` parameter)
    *   `Resolved_DP_Task_Artifacts_Subdir` (from `TASK_ARTIFACTS_SUBDIR` parameter)
    *   `Resolved_DP_Mode_KB_Root` (e.g., "promptu/kb/" or "promptu_dev/kb/")
    *   `Resolved_DP_Project_KB_Path` (e.g., "[Resolved_DP_Mode_KB_Root][Resolved_DP_Project_Name]/")
    *   `Resolved_DP_Main_Research_KB_SubPath` (e.g., "[Resolved_DP_Project_KB_Path]phase0_initial_research/" - this is for research done by dev_planner itself)
    *   `Resolved_DP_Master_Domain_Log_Path` (e.g., "[Resolved_DP_Project_KB_Path]master_domain_log.md" or a global one like "../../aidentity/kb/master_domain_log.md")
    *   `Resolved_DP_Workflow_Type` (from WORKFLOW_TYPE parameter)
    *   `Resolved_DP_Planning_Input_Concepts_Dir` (from `PLANNING_INPUT_CONCEPTS_DIR` parameter)
    *   `Resolved_DP_Project_Specifications_Ref` (from `PROJECT_SPECIFICATIONS_REF` parameter)
    *   `Resolved_DP_Plan_Methodology_Guides` (from `PLAN_METHODOLOGY_GUIDES` parameter)
    *   `Resolved_DP_Plan_Exemplar_Refs` (from `PLAN_EXEMPLAR_REFS` parameter)

D.  **Path Construction Principle:**
    All output paths generated by *this* `dev_planner` addon (for the main plan, TLP, task prompts, and paths referenced *within* those task prompts) MUST be constructed based on these `Resolved_DP_...` parameters. Ensure paths are clear and typically relative to the repository root (unless `Resolved_DP_Base_Output_Path` is an absolute path).

E.  **Conflict and Ambiguity Resolution Protocol:**
    Throughout all planning stages, if you (the AI running `dev_planner`) or any Task AI you spawn identifies critical conflicts or ambiguities within or between documents in `Resolved_DP_Project_Specifications_Ref` (or other guiding documents) that prevent confident decision-making:
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    1.  **HALT** the specific planning or task generation step.
    2.  **Present the Issue Clearly to the User:**
        *   Identify the source documents and specific sections/items that are conflicting or ambiguous.
        *   Clearly articulate the nature of the conflict (e.g., "Requirement A.1 states X, while Requirement B.2 states Y, and these are mutually exclusive for component Z.")
        *   For ambiguities, explain the different potential interpretations and why the ambiguity is blocking (e.g., "Requirement C.3 states 'system must be performant,' which could mean response times under 1s or resource utilization below 50%. Clarification is needed to select appropriate architecture for module W.")
    3.  **Request Specific Clarification:** Ask the user to provide a decision, clarify the requirement, or confirm the correct interpretation.
    4.  **Document and Resume:** Once clarification is received from the user, document this clarification (e.g., in an assumptions log or directly in the evolving plan document). Then, resume the planning process using the user's feedback.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    5.  Spawned Task AIs that detect such issues relevant to their specific task should typically report them back to `dev_planner` (or the orchestrating AI) or, if severe, directly to the user as per their prompt's error handling instructions, possibly by HALTING their own execution and clearly stating the problem.

F.  **Mandatory User Confirmation of Inputs (Initial Step):**
    1.  **VERY FIRST OPERATIONAL STEP:** After resolving all parameters as detailed in Section I.B & I.C, and before proceeding to any research or planning task (Section II.0 onwards):
        a.  You MUST generate a comprehensive summary of all resolved `Resolved_DP_...` input parameters, listing each parameter and its resolved value. This includes paths, flags, workflow type, etc.
        b.  Also, clearly state your understanding of the `User_High_Level_Project_Goal` (obtained from the orchestrator, e.g., `PromptuDev_AI`).
        c.  Present this complete summary to the user.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
        d.  You MUST then HALT and explicitly ask the user for confirmation to proceed (e.g., "Please review the above resolved parameters and project goal understanding. Proceed with planning? (Y/N)").
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
        e.  If the user responds "N" or indicates any issues, you MUST HALT further operations and advise the user to correct their input prompt (e.g., the `[[USER_CONFIG_FOR_dev_planner]]` block or `[[USER_PROJECT_REQUEST]]` in the `PromptuDev_AI`'s `post_promptu.txt`) and re-invoke `dev_planner` (via `PromptuDev_AI`). Do not attempt to self-correct these primary inputs at this stage.

G.  **Processing List-Based Path Parameters (Methodology Guides & Exemplars):**
    1.  **Methodology Guides (`Resolved_DP_Plan_Methodology_Guides`):**
        a.  If this parameter resolves to a list of paths/URLs: For each item in the list that is a repository directory path, you MUST traverse that directory (recursively, if subdirectories are present) and expand it into a list of all relevant individual file paths (e.g., `.md`, `.txt`, `.pdf`). URLs pointing to specific files remain as is.
        b.  The final `Resolved_DP_Plan_Methodology_Guides` internal variable should then be an updated list containing only full file paths and/or URLs to specific documents. This expanded list is what will be used when these guides are referenced later.
    2.  **Plan Exemplars (`Resolved_DP_Plan_Exemplar_Refs`):**
        a.  This parameter is expected to be a list of specific file paths or URLs after initial resolution (as per Section I.B note).
        b.  **Consistency/Conflict Check:** If multiple exemplars are provided in `Resolved_DP_Plan_Exemplar_Refs`, perform a high-level review of their content. If you find exemplars that provide directly contradictory structural or stylistic instructions for similar planning elements (e.g., one exemplar mandates Mermaid diagrams for all flows, another explicitly forbids them for similar contexts), and this would make it impossible to apply them consistently, you MUST use the Conflict and Ambiguity Resolution Protocol (Section I.E) to query the user for clarification on which exemplar to prioritize or how to resolve the conflict. This check should occur before these exemplars are heavily relied upon in detailed plan document generation. If no direct conflicts in instruction are found, proceed. Minor stylistic variations are acceptable.

**II.0. OPERATIONAL CONTEXT & INITIAL RESEARCH**
    **A. Phase Awareness & Orchestration Context:**
        1. You (`dev_planner`) will typically be invoked by an orchestrating AI (e.g., `PromptuDev_AI`) which manages the overall "Iterative Phased Development Process."
        2. Your operations may be scoped to a "Current Phase ID" or a specific "Current Phase Objective" provided by the orchestrator (e.g., via `User_High_Level_Project_Goal` or other contextual parameters). All planning outputs (main plan documents, Task Launch Plans) MUST be clearly titled and internally structured to reflect this current phase scope.
        3. During "Phase 0: Initialization & Comparative Analysis" (orchestrated by `PromptuDev_AI`), you may be invoked with specific goals like:
            a.  "Analyze User Plan": Load and analyze the plan from `Resolved_DP_User_Plan_Proposal_Path`. Your output should be a structured summary of this plan and any immediate, obvious alignments or misalignments with `Resolved_DP_Project_Specifications_Ref`.
            b.  "Generate AI Outline": Analyze `Resolved_DP_Project_Specifications_Ref` to produce a high-level AI-proposed plan outline (e.g., list of phases, primary objectives per phase).
            Your outputs for these specific Phase 0 invocations should be tailored to assist the orchestrator in its comparative analysis and user dialogue.

    **B. Initial Research Phase and Knowledge Base Setup (Corresponds to original II.0):**
        a.  Determine `Resolved_DP_Mode_KB_Root` based on `Is_Developer_Session` (e.g., if true, `promptu_dev/kb/`, else `promptu/kb/`).
    b.  Construct the following paths:
        *   `Resolved_DP_Project_KB_Path = [Resolved_DP_Mode_KB_Root][Resolved_DP_Project_Name]/`
        *   `Resolved_DP_Main_Research_KB_SubPath = [Resolved_DP_Project_KB_Path]phase0_initial_research/`
        *   `Resolved_DP_Master_Domain_Log_Path = [Resolved_DP_Mode_KB_Root]master_domain_log.md` (Note: Using a global log for now, can be project-specific later if needed).
    c.  **Process Planning Input Concepts (if provided):**
        1.  Initialize an internal variable `Extracted_Input_Concepts_Topics` as an empty list or collection.
        2.  Check if `Resolved_DP_Planning_Input_Concepts_Dir` is provided (not N/A or empty) and points to an existing directory.
        3.  If yes:
            a.  List all files within `Resolved_DP_Planning_Input_Concepts_Dir`.
            b.  For each file:
                i.  Perform a conceptual analysis (e.g., summarization, keyword/topic extraction) to identify key concepts, questions, or main themes.
                ii. Append these extracted items to `Extracted_Input_Concepts_Topics`.
    d.  (Placeholder for defining "Task 0" for initial research - this will involve invoking `create_research_report` addon).
    e.  **Preliminary Review of Project Specifications:**
        1.  Before configuring the research task, perform a preliminary review of the documents/URLs provided in `Resolved_DP_Project_Specifications_Ref` (if any).
        2.  The purpose is to identify any obvious, high-level contradictions or critical ambiguities that would significantly hinder the initial research phase by making its scope unclear or its goals unachievable.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
        3.  If such show-stopping issues are identified (e.g., core requirements that are mutually exclusive, key terms defined inconsistently across essential documents), HALT operations and present these critical conflicts/ambiguities to the user for clarification. State clearly that proceeding with research without resolving these foundational issues would be counterproductive.
        4.  If no such critical preliminary issues are found, or if `Resolved_DP_Project_Specifications_Ref` is not provided, proceed to configure and invoke `create_research_report`.
    f.  Instructions for `dev_planner` when preparing its own "Task 0" (initial research task) which invokes `create_research_report`:
        i.  You MUST construct a `[[USER_CONFIG_FOR_create_research_report]]` block. This block will set the following parameters for the `create_research_report` addon:
            *   `RESEARCH_TOPIC_OR_QUESTIONS`: Synthesize this from a combination of `User_High_Level_Project_Goal` and any items in `Extracted_Input_Concepts_Topics` (from step II.0.c). Ensure the topics are comprehensive and cover all provided inputs and align with the reviewed project specifications.
            *   `PRIMARY_SPECIFICATION_DOCS`: Set using the list of paths/URLs from `Resolved_DP_Project_Specifications_Ref`. (Ensure this is passed as a list or correctly formatted comma-separated string if `create_research_report` expects that).
            *   `GUIDELINES_DOC_PATHS`: Set using the list of paths/URLs from `Resolved_DP_Plan_Methodology_Guides`. (Ensure this is passed as a list or correctly formatted comma-separated string if `create_research_report` expects that).
            *   `EXPERT_CONTENT_PATH`: Set to `../../aidentity/kb/[Resolved_DP_Project_Name]/phase0_initial_research/`
            *   `EXPERT_FILENAME_OVERRIDE`: Set to a descriptive name like `"[Resolved_DP_Project_Name]_initial_research_expert.md"`
            *   `REFERENCE_LIST_PATH`: Set to `../../aidentity/kb/[Resolved_DP_Project_Name]/phase0_initial_research/`
            *   `REFERENCE_FILENAME_OVERRIDE`: Set to a descriptive name like `"[Resolved_DP_Project_Name]_initial_research_refs.md"`
            *   `RESEARCH_REPORT_OUTPUT_PATH`: Set to `../../aidentity/kb/[Resolved_DP_Project_Name]/phase0_initial_research/` (to store the report alongside its KB outputs).
            *   `RESEARCH_REPORT_FILENAME`: Set to a descriptive name like `"[Resolved_DP_Project_Name]_initial_research_report.md"`
            *   `MASTER_DOMAIN_LOG_PATH`: Set to `../../aidentity/kb/master_domain_log.md`
            *   `DOMAIN_NAME_FOR_LOG`: Set to a unique name like `"[Resolved_DP_Project_Name]_InitialResearch"`
            *   `ITERATIVE_OUTPUT_DEPTH`: [USER_VALUE_START] 2 [USER_VALUE_END]
    g.  (Placeholder for ensuring subsequent planning phases use the output of this "Task 0").
    h.  **Apply Interface-Based Design Principles & Leverage Knowledge Base:** Following this initial research, and throughout all subsequent planning and task definition stages (regardless of workflow), you MUST actively incorporate and promote the use of interface-based design principles to maximize merge conflict mitigation and enable effective parallelism. To achieve this:
                    1.  **Consult General Principles:** Begin by reviewing the broad principles in `../../aidentity/kb/interface_based_design_best_practices/expert_L1.md`.
                    2.  **Identify Relevant Specialized KBs:** Determine which of the specialized domains are most relevant to the current project or module being planned:
                        *   Rust: `../../aidentity/kb/rust_software_partitioning/`
                        *   Java: `../../aidentity/kb/java_software_partitioning/`
                        *   OS-level: `../../aidentity/kb/os_software_partitioning/`
                        *   Kernel-level (incl. boot/init): `../../aidentity/kb/kernel_software_partitioning/`
                        *   Application Architecture: `../../aidentity/kb/app_software_partitioning/`
                    3.  **Utilize Leveled Knowledge:** For each relevant specialized domain:
                        a.  **Start with L0 (`expert_L0.md`):** Use this to gain a comprehensive foundational understanding of the main topic and to identify key sub-topics/facets and their initial detailed explanations.
                        b.  **Proceed to L1 (`expert_L1.md`):** For the sub-topics identified as critical from L0, consult the L1 expert file for significantly more detailed explanations, patterns, examples, and advanced considerations.
                    4.  **Synthesize and Apply:** Synthesize the information from the general KB and the relevant L0 and L1 specialized KBs to guide the definition of clear module boundaries, robust APIs, explicit contracts, and well-encapsulated components. This informed approach is critical for decomposing work effectively for parallel development and minimizing merge conflicts.
                    5.  (All KB files mentioned are in the repo).
    f.  **Determine Workflow Path and Execute Primary Planning Logic:**
        **Phase Scope Note:** Regardless of the workflow chosen below, remember that your planning might be for a specific "Current Phase ID" or "Current Phase Objective" if provided by the orchestrating AI (see II.0.A). Ensure your outputs are scoped and titled accordingly.

        Based on `Resolved_DP_Workflow_Type`:
        *   IF `Resolved_DP_Workflow_Type` is "Monolithic":
            // Proceed with instructions in Section II.1 (Monolithic Workflow)
            Proceed with instructions in Section II.1 onwards.
        *   ELSE IF `Resolved_DP_Workflow_Type` is "DelegatedPlanning":
            INFO: "DelegatedPlanning workflow selected. This workflow is typically used for initial detailed planning of the entire project or a major segment, focusing on decomposition into plannable sub-modules."
            1.  **Analyze Project for Planning Decomposition:** Based on `User_High_Level_Project_Goal`, the enhanced initial research report (from Section II.0.B), and a thorough analysis of *all documents/URLs* within `Resolved_DP_Project_Specifications_Ref` (if provided), identify 2-5 major components, modules, or work areas.
                *   You MUST analyze these specifications for any internal conflicts or critical ambiguities that would affect decomposition.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                *   If such issues are found that prevent a clear decomposition, HALT and use the protocol in Section I.E to query the user.
                *   All decomposition decisions MUST be demonstrably consistent with the (clarified, if necessary) `Resolved_DP_Project_Specifications_Ref`. These areas require separate, detailed sub-planning.
            2.  **Define Planning Sub-Tasks:** For each identified component/module:
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                a.  Formulate a clear objective for a "Planning Task AI". This objective MUST state: "Create a detailed development sub-plan for the '[Component Name]' module. This sub-plan must be as detailed as the main plan's target quality. **Your primary responsibility is to ensure all aspects of this sub-plan (architecture, technology choices, APIs, task breakdown, acceptance criteria) strictly adhere to *all relevant specifications* found within the `[Resolved_DP_Project_Specifications_Ref]` (list of documents/URLs, it is in the repo). You MUST analyze these specifications for any conflicts or ambiguities directly impacting your assigned module. If critical issues are found, you must report them clearly in your output, potentially recommending a HALT to this sub-planning task until clarification is provided by the orchestrator or user.** The style, level of detail, and representation of elements in your sub-plan document MUST be guided by the examples found in `[Resolved_DP_Plan_Exemplars_Dir]` (it is in the repo). Furthermore, you MUST review the list of methodology guides provided in `Resolved_DP_Plan_Methodology_Guides` (this list will be passed as part of your context/prompt) and apply any relevant guidance from these documents to your planning process, the structure of your outputted sub-plan, and any processes you define within your sub-plan. A primary focus of this sub-plan is to explicitly define and leverage interface-based design by thoroughly utilizing the available knowledge base. Your process for this sub-plan MUST be:**
    **1. Review General Principles:** Start with `../../aidentity/kb/interface_based_design_best_practices/expert_L1.md`.
    **2. Identify Relevant Specialized Domain(s) for '[Component Name]':** Determine if '[Component Name]' primarily involves Rust, Java, OS-level work, Kernel-level work, or specific Application Architectures, and thus which of these KBs is most applicable:
        *   `../../aidentity/kb/rust_software_partitioning/`
        *   `../../aidentity/kb/java_software_partitioning/`
        *   `../../aidentity/kb/os_software_partitioning/`
        *   `../../aidentity/kb/kernel_software_partitioning/`
        *   `../../aidentity/kb/app_software_partitioning/`
    **3. Detailed Study of Leveled KB for Relevant Domain(s):**
        *   **Consult `expert_L0.md` first:** For each highly relevant domain, thoroughly study its `expert_L0.md` to understand the foundational concepts, key sub-topics, and their initial detailed explanations related to '[Component Name]'.
        *   **Deep Dive with `expert_L1.md`:** For the sub-topics identified from L0 as most critical to '[Component Name]', you MUST then consult the corresponding `expert_L1.md`. This L1 report provides significantly greater depth, examples, and advanced considerations that are essential for your detailed planning.
    **4. Apply Synthesized Knowledge:** Use the synthesized knowledge from these general and leveled KBs (all in the repo) to establish clear APIs, contracts, and boundaries for all components within '[Component Name]' and for its external interactions. This is critical for minimizing merge conflicts and enabling parallel development of subsequent tasks.**").
                b.  This Planning Task AI MAY be authorized to conduct further focused research if essential for its sub-planning task. If so, configure its research outputs to a unique subdirectory within `[Resolved_DP_Project_KB_Path]`, e.g., `[Resolved_DP_Project_KB_Path]planning_task_[ComponentName]_research/`, ensuring the `Resolved_DP_Master_Domain_Log_Path` is used for log updates.
                c.  The primary output for each Planning Task AI is a Markdown sub-plan document (e.g., `[ComponentName]_sub_plan.md`) to be saved in `[Resolved_DP_Submodule_Plans_Subdir]/planning_phase/`. The content and structure of this document should be informed by exemplars in `[Resolved_DP_Plan_Exemplars_Dir]` (it is in the repo).
            3.  **Generate Prompts for Planning Task AIs:** For each planning sub-task, generate a dedicated task prompt file in `[Resolved_DP_Task_Prompts_Subdir]/planning_phase/` using the naming convention `p0_planning_t[N]_[component_name].txt`. These prompts MUST explicitly reiterate the requirement for the Planning Task AI to analyze and adhere to all documents in `[Resolved_DP_Project_Specifications_Ref]` and consult `[Resolved_DP_Plan_Exemplars_Dir]`, including the conflict/ambiguity analysis duty. They should follow the general structure outlined in Section III.B of this document, but with the "Task Execution Instructions" focused on research (if enabled) and detailed sub-plan document creation.
            4.  **Update Task Launch Plan (TLP):** Modify the `00_task_launch_plan.md` (as defined in Section III.C) to:
                a.  Clearly state that the first phase is "Phase 0: Delegated Planning".
                b.  List all generated "Planning Task AI" prompts with their objectives and launch commands.
                c.  Add a section after Phase 0 tasks: "**User Action Required: Plan Merging & Approval.** After all Planning Task AIs complete, their generated sub-plans (located in `[Resolved_DP_Submodule_Plans_Subdir]/planning_phase/`) must be reviewed and merged by the User (or a dedicated Plan Merging AI task, if developed) into the main `[Resolved_DP_Main_Dev_Plan_Filename]`. This merged and approved Main Development Plan will be the input for subsequent developer task spawning."
            5.  **Prepare for Handoff/Continuation:**
                a.  The `dev_planner`'s current execution effectively concludes after generating these planning tasks and the updated TLP.
                b.  The AI (running `dev_planner`) MUST ensure the main session `handoff_notes.md` is updated to reflect:
                    i.  Current state: `dev_planner` (DelegatedPlanning workflow) has spawned planning sub-tasks.
                    ii. Path to the TLP: `[Resolved_DP_Task_Prompts_Subdir]/00_task_launch_plan.md`.
                    iii. Paths to expected sub-plan outputs: `[Resolved_DP_Submodule_Plans_Subdir]/planning_phase/`.
                    iv. Clear instructions that the next overall step is User review and merging of sub-plans into `[Resolved_DP_Main_Dev_Plan_Filename]`.
                    v.  Indication that `dev_planner` (or a different orchestrator) can be re-invoked with the finalized `[Resolved_DP_Main_Dev_Plan_Filename]` to proceed with spawning developer tasks for project execution.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                c.  HALT execution of this `dev_planner` instance. The framework will then proceed based on the updated handoff notes (e.g., by awaiting user action or prompting for the next step).
        *   ELSE IF `Resolved_DP_Workflow_Type` is "HybridIterative":
            INFO: "HybridIterative workflow selected."
            // This workflow requires dev_planner to be resumable and stateful via main handoff notes.
            // It will manage planning and execution one phase/module at a time, making it suitable for iterative execution or for handling specific, complex phases identified by PromptuDev_AI.

            1.  **Determine Current Iteration State:**
                a.  Check main session `handoff_notes.md` for a "Pending Task" entry related to this `dev_planner` (HybridIterative) instance.
                b.  If found, parse it to determine:
                    i.  The `Current_Phase_Or_Module_ID` being processed.
                    ii. The `Current_Iteration_Step` (e.g., "AwaitingSubPlanApproval", "ReadyToSpawnDevTasks", "AwaitingPhaseCompletion").
                    iii. Paths to any relevant plans (e.g., overall project outline, approved sub-plan for the current phase).
                c.  If not found (first invocation for this workflow):
                    i.  Set `Current_Phase_Or_Module_ID` to the first phase/module identified from the `User_High_Level_Project_Goal` and initial research (from II.0.e).
                    ii. Set `Current_Iteration_Step` to "PlanCurrentPhase".

            2.  **Execute Current Iteration Step:**

                *   **IF `Current_Iteration_Step` is "PlanCurrentPhase":**
                    a.  **Focused Planning for Current Phase/Module:** Perform detailed planning *only* for `Current_Phase_Or_Module_ID`. This planning MUST be based on a thorough analysis of *all documents/URLs* within `Resolved_DP_Project_Specifications_Ref` (it is in the repo), alongside insights from the enhanced initial research (Section II.0).
                        *   You MUST analyze these specifications for any internal conflicts or critical ambiguities relevant to the `Current_Phase_Or_Module_ID`.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                        *   If such issues are found that prevent clear planning for this phase, HALT and use the protocol in Section I.E to query the user.
                        *   All planning decisions must be traceable to the (clarified, if necessary) `Resolved_DP_Project_Specifications_Ref`. This may involve invoking a focused research task.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                    b.  **Generate Planning Task AI Prompt:** Create a task prompt (e.g., `[Resolved_DP_Task_Prompts_Subdir]/hybrid_phase_[Current_Phase_Or_Module_ID]_planning_prompt.txt`) for a "Planning Task AI". This prompt instructs the Task AI to generate a detailed sub-plan document for `Current_Phase_Or_Module_ID` (to be saved in `[Resolved_DP_Submodule_Plans_Subdir]/hybrid_phase_[Current_Phase_Or_Module_ID]_subplan.md`). The objective for the Planning Task AI (which will be written into its prompt) MUST include: "This sub-plan MUST detail the architecture, key functions, data models, and API specifications for `Current_Phase_Or_Module_ID`. **Your primary responsibility is to ensure all aspects of this sub-plan strictly adhere to *all relevant specifications* found within `[Resolved_DP_Project_Specifications_Ref]` (list of documents/URLs, it is in the repo). You MUST analyze these specifications for any conflicts or ambiguities directly impacting the current phase. If critical issues are found, you must report them clearly in your output, potentially recommending a HALT to this sub-planning task until clarification is provided by the orchestrator or user.** The style, level of detail, and representation of elements in your sub-plan document MUST be guided by the examples found in `[Resolved_DP_Plan_Exemplars_Dir]` (it is in the repo). Furthermore, you MUST review the list of methodology guides provided in `Resolved_DP_Plan_Methodology_Guides` (this list will be passed as part of your context/prompt) and apply any relevant guidance from these documents to your planning process, the structure of your outputted sub-plan, and any processes you define within your sub-plan. A core requirement is to meticulously apply interface-based design by thoroughly utilizing the available knowledge base. Your process for this sub-plan MUST be:**
    **1. Review General Principles:** Start with `../../aidentity/kb/interface_based_design_best_practices/expert_L1.md`.
    **2. Identify Relevant Specialized Domain(s) for `Current_Phase_Or_Module_ID`:** Determine if the current phase/module primarily involves Rust, Java, OS-level work, Kernel-level work, or specific Application Architectures, and thus which of these KBs is most applicable:
        *   `../../aidentity/kb/rust_software_partitioning/`
        *   `../../aidentity/kb/java_software_partitioning/`
        *   `../../aidentity/kb/os_software_partitioning/`
        *   `../../aidentity/kb/kernel_software_partitioning/`
        *   `../../aidentity/kb/app_software_partitioning/`
    **3. Detailed Study of Leveled KB for Relevant Domain(s):**
        *   **Consult `expert_L0.md` first:** For each highly relevant domain, thoroughly study its `expert_L0.md` to understand the foundational concepts, key sub-topics, and their initial detailed explanations related to `Current_Phase_Or_Module_ID`.
        *   **Deep Dive with `expert_L1.md`:** For the sub-topics identified from L0 as most critical, you MUST then consult the corresponding `expert_L1.md` for significantly greater depth.
    **4. Apply Synthesized Knowledge:** Use these resources (all in the repo) to define robust interfaces and boundaries that will reduce merge conflicts and facilitate parallel workstreams for this phase/module and its interactions.**"
                    c.  **Update TLP:** Add this planning task to `00_task_launch_plan.md` under a section for the current phase.
                    d.  **Handoff for Sub-Plan Approval:** Update main session `handoff_notes.md` to state:
                        - `dev_planner` (HybridIterative) is paused.
                        - `Current_Phase_Or_Module_ID` is `[Current_Phase_Or_Module_ID]`.
                        - `Current_Iteration_Step` is now "AwaitingSubPlanApproval".
                        - Planning Task AI spawned: `[prompt_filename]`.
                        - Path to expected sub-plan: `[path_to_subplan.md]`.
                        - Next action: User to review and approve/modify the sub-plan. `dev_planner` to be re-invoked once sub-plan is ready.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                    e.  HALT.

                *   **ELSE IF `Current_Iteration_Step` is "AwaitingSubPlanApproval":**
                    a.  Instruct user: "Please review and finalize the sub-plan for phase/module `[Current_Phase_Or_Module_ID]` located at `[path_to_subplan.md]`. Once finalized, re-invoke `dev_planner`."
                    b.  (Optional: `dev_planner` could attempt to read the sub-plan and ask for explicit approval if it can determine its readiness).
                    c.  **Handoff for Action:** Update main session `handoff_notes.md` to reflect it's awaiting user finalization of the sub-plan for `[Current_Phase_Or_Module_ID]`. `Current_Iteration_Step` remains "AwaitingSubPlanApproval" or moves to "ReadyToSpawnDevTasks" upon user confirmation of plan readiness.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                    d.  HALT.

                *   **ELSE IF `Current_Iteration_Step` is "ReadyToSpawnDevTasks":**
                    a.  **Load Approved Sub-Plan:** Assume the sub-plan for `Current_Phase_Or_Module_ID` (at `[Resolved_DP_Submodule_Plans_Subdir]/hybrid_phase_[Current_Phase_Or_Module_ID]_subplan.md`) is finalized and has been verified for compliance with `Resolved_DP_Project_Specifications_Ref`.
                    b.  **Generate Developer Task AI Prompts:**
                        i.   Before generating prompts for this phase/module, iterate through each guide path/URL in `Resolved_DP_Plan_Methodology_Guides`. For each guide, attempt to infer its primary purpose or domain (e.g., from its filename, such as 'documentation_guide.md', 'api_style_guide.md', 'testing_process.md'). Store these inferences.
                        ii.  Based on the loaded sub-plan, generate all developer task prompts for `Current_Phase_Or_Module_ID`. These prompts (following Section III.B) MUST instruct Task AIs that their implementation details, testing, and acceptance criteria need to be demonstrably consistent with *all relevant documents* in `Resolved_DP_Project_Specifications_Ref` (it is in the repo).
                        iii. For each generated developer task prompt, assess if the nature of the task aligns with the inferred purpose of any methodology guides. If a relevant guide is identified, ensure the prompt (e.g., in section III.B.3.a) includes a clear instruction to the Developer Task AI to consult that specific guide(s) from `Resolved_DP_Plan_Methodology_Guides`.
                        iv.  Outputs go to `[Resolved_DP_Task_Artifacts_Subdir]/[Current_Phase_Or_Module_ID]/[TaskName]/`.
                    c.  **Update TLP:** Add these developer tasks to `00_task_launch_plan.md` under the current phase.
                    d.  **Handoff for Phase Execution:** Update main session `handoff_notes.md`:
                        - `dev_planner` (HybridIterative) has spawned developer tasks for phase `[Current_Phase_Or_Module_ID]`.
                        - `Current_Iteration_Step` is now "AwaitingPhaseCompletion".
                        - List spawned developer tasks.
                        - Next action: Developer tasks to be executed. User to merge results. `dev_planner` to be re-invoked after phase completion.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                    e.  HALT.

                *   **ELSE IF `Current_Iteration_Step` is "AwaitingPhaseCompletion":**
                    a.  Instruct user: "Developer tasks for phase/module `[Current_Phase_Or_Module_ID]` have been defined. Please ensure their execution and merge outputs. Once this phase is considered complete, re-invoke `dev_planner` to proceed to the next phase or conclude."
                    b.  **Handoff for Action:** Update main session `handoff_notes.md`. `Current_Iteration_Step` remains "AwaitingPhaseCompletion".
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                    c.  HALT.

            3.  **Loop or Conclude:** (This logic would be part of `dev_planner`'s startup when re-invoked after "AwaitingPhaseCompletion")
                a.  Determine if there is a next phase/module in the overall project structure (derived from `User_High_Level_Project_Goal` or the initial top-level plan).
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                b.  If yes: Set `Current_Phase_Or_Module_ID` to the next phase/module, change `Current_Iteration_Step` to "PlanCurrentPhase", and re-enter logic at step II.0.f.2 (Execute Current Iteration Step). Update handoff notes accordingly. HALT (to allow the new cycle to begin cleanly).
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
                c.  If no: Project is complete. Generate final summary/report if needed. Update handoff notes to reflect overall project completion by `dev_planner`. HALT.
        *   ELSE (Unknown workflow type):
            WARNING: "Unknown WORKFLOW_TYPE: '[Resolved_DP_Workflow_Type]'. Defaulting to Monolithic workflow."
            Set `Resolved_DP_Workflow_Type` internally to "Monolithic" and proceed with Section II.1.

**II.1. MONOLITHIC WORKFLOW: Project Decomposition, Sub-Planning, and Developer Task Generation**
    **Phase Scope Note:** If this workflow is invoked for a specific phase (see II.0.A), the "project" decomposition below should focus on sub-modules *within* that phase. If for initial overall planning, it addresses the entire project.

1.  **Decompose Project into Modules:**
    Based on `User_High_Level_Project_Goal` (potentially phase-scoped), the enhanced initial research report (from Section II.0.B), and critically, a thorough analysis of *all documents/URLs* within `Resolved_DP_Project_Specifications_Ref` (if provided, it is in the repo), decompose the overall project (or current phase) into a list of 2-5 logical/functional modules.
    *   You MUST analyze these specifications for any internal conflicts or critical ambiguities that would affect decomposition.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    *   If such issues are found that prevent a clear decomposition, HALT and use the protocol in Section I.E to query the user.
    *   All module definitions, boundaries, and high-level responsibilities MUST be demonstrably consistent with the (clarified, if necessary) `Resolved_DP_Project_Specifications_Ref`. Each module will have its own submodule development plan.

2.  **Create/Update Main Overview Document (`MAIN_DEV_PLAN_FILENAME`):**
    Create or update the document specified by `[Resolved_DP_Main_Dev_Plan_Filename]` (e.g., `main_dev_plan_overview.md`). The style and structure of this document should be informed by any relevant examples in `[Resolved_DP_Plan_Exemplars_Dir]` (it is in the repo). This document MUST:
    a.  Briefly introduce each identified module, ensuring descriptions align with `Resolved_DP_Guiding_Specifications_Ref`.
    b.  State that detailed development sub-plans (which must also adhere to `Resolved_DP_Guiding_Specifications_Ref` and `Resolved_DP_Plan_Exemplars_Dir`) will be generated for each module.
    c.  Contain placeholders or a structure where links to each `[ModuleName]_submodule_dev_plan.md` can be added later (or this document can serve as a manifest listing them).

3.  **Generate Sub-Planning Task Prompts:**
    For each identified module:
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    a.  Define an objective for a "Sub-Planning Task AI" to create a detailed `[ModuleName]_submodule_dev_plan.md`. The objective MUST clearly state: "The sub-plan must cover architecture, key functions, data models, API specs, potential challenges, and developer tasks for '[ModuleName]'. **Your primary responsibility is to ensure all aspects of this sub-plan (architecture, technology choices, APIs, task breakdown, acceptance criteria) strictly adhere to *all relevant specifications* found within `[Resolved_DP_Project_Specifications_Ref]` (list of documents/URLs, it is in the repo). You MUST analyze these specifications for any conflicts or ambiguities directly impacting your assigned module. If critical issues are found, you must report them clearly in your output, potentially recommending a HALT to this sub-planning task until clarification is provided by the orchestrator or user.** The style, level of detail, and representation of elements in your sub-plan document MUST be guided by the examples found in `[Resolved_DP_Plan_Exemplars_Dir]` (it is in the repo). Furthermore, you MUST review the list of methodology guides provided in `Resolved_DP_Plan_Methodology_Guides` (this list will be passed as part of your context/prompt) and apply any relevant guidance from these documents to your planning process, the structure of your outputted sub-plan, and any processes you define within your sub-plan. A primary focus of this sub-plan is to explicitly define and leverage interface-based design by thoroughly utilizing the available knowledge base. Your process for this sub-plan MUST be:**
    **1. Review General Principles:** Start with `../../aidentity/kb/interface_based_design_best_practices/expert_L1.md`.
    **2. Identify Relevant Specialized Domain(s) for '[ModuleName]':** Determine if '[ModuleName]' primarily involves Rust, Java, OS-level work, Kernel-level work, or specific Application Architectures, and thus which of these KBs is most applicable:
        *   `../../aidentity/kb/rust_software_partitioning/`
        *   `../../aidentity/kb/java_software_partitioning/`
        *   `../../aidentity/kb/os_software_partitioning/`
        *   `../../aidentity/kb/kernel_software_partitioning/`
        *   `../../aidentity/kb/app_software_partitioning/`
    **3. Detailed Study of Leveled KB for Relevant Domain(s):**
        *   **Consult `expert_L0.md` first:** For each highly relevant domain, thoroughly study its `expert_L0.md` to understand the foundational concepts, key sub-topics, and their initial detailed explanations related to '[ModuleName]'.
        *   **Deep Dive with `expert_L1.md`:** For the sub-topics identified from L0 as most critical to '[ModuleName]', you MUST then consult the corresponding `expert_L1.md` for significantly greater depth.
    **4. Apply Synthesized Knowledge:** Use the synthesized knowledge from these general and leveled KBs (all in the repo) to establish clear APIs, contracts, and boundaries for all components within '[ModuleName]' and for its external interactions. This is critical for minimizing merge conflicts and enabling parallel development of subsequent tasks.**
    b.  This Sub-Planning Task AI MAY be authorized for further focused research. If enabled, configure its research outputs to a unique subdirectory within `[Resolved_DP_Project_KB_Path]` (e.g., `[Resolved_DP_Project_KB_Path]module_[ModuleName]_planning_research/`), ensuring `[Resolved_DP_Master_Domain_Log_Path]` is used for log updates and a unique domain name (e.g., `[Resolved_DP_Project_Name]_Module_[ModuleName]_PlanningResearch`) is set.
    c.  The primary output `[ModuleName]_submodule_dev_plan.md` is to be saved in `[Resolved_DP_Submodule_Plans_Subdir]/`.
    d.  Generate a task prompt file (e.g., `[Resolved_DP_Task_Prompts_Subdir]/module_planning_[ModuleName].txt`) for this sub-planning task, following the structure in Section III.B, tailored for planning.

4.  **Update Task Launch Plan (TLP) for Sub-Planning Phase:**
    Modify `00_task_launch_plan.md` (as per Section III.C) to:
    a.  Clearly title this phase, e.g., "Phase 0: Project Decomposition and Sub-Planning Task Generation".
    b.  List all generated "Sub-Planning Task AI" prompts, their objectives, and launch commands.

5.  **Handoff for User Review of Decomposition & Sub-Planning Tasks:**
    The AI (running `dev_planner`) MUST ensure the main session `handoff_notes.md` is updated to reflect:
    - Current state: `dev_planner` (Monolithic workflow) has produced an initial project decomposition (overview in `[Resolved_DP_Main_Dev_Plan_Filename]`) and generated tasks for detailing submodule plans (listed in TLP).
    - `Current_Workflow_Step` (or similar state variable for handoff notes): "AwaitingDecompositionAndSubPlanTaskApproval".
    - Paths to review: `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Main_Dev_Plan_Filename]` and `[Resolved_DP_Task_Prompts_Subdir]/00_task_launch_plan.md`.
    - Next User Action: "Review project decomposition and the set of sub-planning tasks. Approve or request modifications. Re-invoke `dev_planner` with state/context indicating approval to proceed with sub-plan execution."
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    - HALT execution of this `dev_planner` instance.

6.  **Resumption: Generate Developer Tasks from Completed Submodule Plans:**
    This section executes if `dev_planner` is re-invoked and the state in `handoff_notes.md` indicates "AwaitingDeveloperTaskGenerationAfterSubplans" (or similar, meaning sub-planning tasks are complete and their outputs - the `[ModuleName]_submodule_dev_plan.md` files in `[Resolved_DP_Submodule_Plans_Subdir]/` - are ready, approved by the user, and verified for compliance with `Resolved_DP_Project_Specifications_Ref` and `Resolved_DP_Plan_Exemplars_Dir`).
    a.  **Update Overview Document:** Iterate through each `[ModuleName]_submodule_dev_plan.md` and ensure the `[Resolved_DP_Main_Dev_Plan_Filename]` (overview document) correctly links to or incorporates summaries of these detailed submodule plans, ensuring consistency.
    b.  **Developer Task Generation (adapting original Section II.1 logic like Phased Structure, Granularity, Merge Conflict Mitigation, Naming, Effort, Confidence, Mermaid for TLP):**
        i.   Before generating prompts for the developer tasks within a given module's sub-plan, iterate through each guide path/URL in `Resolved_DP_Plan_Methodology_Guides`. For each guide, attempt to infer its primary purpose or domain (e.g., from its filename, such as 'documentation_guide.md', 'api_style_guide.md', 'testing_process.md'). Store these inferences.
        ii.  Iterate through each approved and compliant `[ModuleName]_submodule_dev_plan.md`:
            1.  Decompose this submodule plan into granular developer tasks for that module. All task definitions, including acceptance criteria and implementation details, MUST be demonstrably consistent with *all relevant documents* in `Resolved_DP_Project_Specifications_Ref` (it is in the repo).
            2.  Apply merge conflict mitigation strategies (prefer new files within `[Resolved_DP_Task_Artifacts_Subdir]/[ModuleName]/[TaskName]/`, serialize if needed, be specific for shared code).
            3.  Generate developer task prompt files (e.g., `[Resolved_DP_Task_Prompts_Subdir]/[ModuleName]_dev_p[Phase#]_t[Task#]_[description].txt`) as per Section III.B. These prompts MUST explicitly instruct Task AIs to ensure their work adheres to *all relevant documents* in `Resolved_DP_Project_Specifications_Ref`. For each generated prompt, assess if the nature of that task aligns with the inferred purpose of any methodology guides (from step b.i). If a relevant guide is identified, ensure the prompt (e.g., in section III.B.3.a) includes a clear instruction to the Developer Task AI to consult that specific guide(s) from `Resolved_DP_Plan_Methodology_Guides`. These prompts should clearly state they are for a specific module.
    c.  **Update TLP for Developer Tasks:** Update `00_task_launch_plan.md` to list all generated developer tasks, organized by module and phase. The Mermaid diagram should reflect this modular, phased developer task structure.
    d.  **Final Handoff for Execution:** Update main session `handoff_notes.md`:
        - Current state: `dev_planner` (Monolithic workflow) has finalized the modular development plan (overview + submodule plans) and generated all developer tasks for the current scope (project or phase).
        - Path to final TLP: `[Resolved_DP_Task_Prompts_Subdir]/00_task_launch_plan.md`.
        - Next Action: User to orchestrate execution of developer tasks.
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
        - HALT.
    **Monolithic Workflow Fallback/Critical Issue Handling:**
    If, during any step of this Monolithic workflow (especially steps 1, 3, or 6), you encounter critical planning failures, unresolvable blockers (e.g., specification conflicts that user clarification via Section I.E does not resolve sufficiently for monolithic breakdown), or an inability to decompose a module/phase effectively:
    IF `Is_Resumable_Session` is true: CALL `Update_My_Handoff_Note()` with current resumable state before this HALT.
    a.  HALT your current planning attempt for this scope.
    b.  In your `handoff_notes.md` or direct output to the orchestrating AI (`PromptuDev_AI`), clearly summarize the critical issues encountered and why monolithic planning is blocked.
    c.  Explicitly suggest that `PromptuDev_AI` offer the user the option to re-attempt planning for this specific scope (phase or sub-module) using either the `DelegatedPlanning` or `HybridIterative` workflow for `dev_planner`. This allows for a more focused, potentially multi-AI approach to resolve the complexity.

**III. OUTPUT GENERATION REQUIREMENTS (Specific to Task Spawning):**

A.  **Main Development Plan Document:**
    *   Develop content based on `User_High_Level_Project_Goal`.
    *   **Location:** `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Main_Dev_Plan_Filename]`.

B.  **Task Prompt Files (`.txt`):**
    *   **Base Location for Task Prompts:** The directory `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/`. All individual task prompt files and the TLP will be saved here.
    *   **For Each Task, Generate a Prompt File Containing:**
        1.  **Task Overview:** Purpose, contribution, reference to Main Dev Plan. If applicable, relevant initial research (which now incorporates `Resolved_DP_Planning_Input_Concepts_Dir` and was guided by `Resolved_DP_Project_Specifications_Ref`) can be found at `[Path_To_DevPlanner_Initial_Research_Report_Placeholder]`. If dependent (from TLP), reiterate dependency (e.g., "Depends on `TaskX_ID`..."). **Crucially, all work for this task MUST adhere to the specifications found in `[Resolved_DP_Project_Specifications_Ref]` (it is in the repo).** Furthermore, be aware that this task is defined within the context of overarching project specifications located at `[Resolved_DP_Project_Specifications_Ref]`; consult these if detailed constraints or architectural context are needed. The overall project plan was also informed by initial input concepts and exemplar styles.
        2.  **Sub-Development Plan Directive:** "Create `<PhaseTaskName>_dev_plan.md` in the directory `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Submodule_Plans_Subdir]/`. List steps; mark progress. **The content, structure, and level of detail in this document MUST be guided by the examples in `[Resolved_DP_Plan_Exemplars_Dir]` (it is in the repo) and all technical decisions must align with `[Resolved_DP_Project_Specifications_Ref]` (it is in the repo).**"
        3.  **Detailed Task Execution Instructions:** Actionable steps, reference inputs. Ensure these instructions are consistent with `Resolved_DP_Project_Specifications_Ref`. (When generating this section of the prompt, `dev_planner` should consider if direct references to specific sections of `Resolved_DP_Project_Specifications_Ref` are necessary for task clarity).
        3.a. **Consult Relevant Methodology Guides:** (This section will be populated by `dev_planner` if specific guides from `Resolved_DP_Plan_Methodology_Guides` are identified as highly relevant to this task. Example: 'For guidance on documentation standards, please consult: [path to document_management_guide.md], it is in the repo. For API design, refer to: [path to api_style_guide.md], it is in the repo.'). If this section is empty, assume no specific methodology guides were flagged as critical for this task, but general best practices should still apply.
        4.  **Output Management:** "Place new, task-specific files in the directory `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Artifacts_Subdir]/<PhaseTaskName>/`. For modifying shared code (if any, assumed to be within `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Artifacts_Subdir]/`), be specific and use IEP `Owned-Files-Modules`."
        5.  **IEP Adherence:** "Follow `information_exchange_protocol.md` (located at `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/information_exchange_protocol.md`, it is in the repo). Focus on `Status`, `Owned-Files-Modules`, `[BLOCKERS / ISSUES]`, `[PROGRESS]`, and **`[RISK_ASSESSMENT]` block.**" (IEP generation is handled by Core Instructions Section III.C.1 and placed in this add-on's task prompts output directory).
        6.  **"Next Steps, Learnings & Improvements" Doc Directive:** "Create `<PhaseTaskName>_next_steps.md` alongside your `dev_plan.md` in the directory `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Submodule_Plans_Subdir]/`. Must include sections: `### Potential Next Steps & Enhancements`, `### Key Learnings & Discoveries` (non-obvious insights, challenges, solutions, assumptions), `### AI-Automated PR Suggestions`, `### Other General Recommendations`."
        7.  **Inter-AI Comm Directive:** "Use the directory `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/ipc/` for persistent logs/artifacts not fitting commits. Document usage in commits." (Ensure this `ipc/` directory is created if needed).
        8.  **Retry Logic:** "```If retrying post-crash, investigate git log, the dev plan at `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Submodule_Plans_Subdir]/<PhaseTaskName>_dev_plan.md`, your task's output directory `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Artifacts_Subdir]/<PhaseTaskName>/`, and logs in `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/ipc/`. Document findings in `dev_plan.md`. Continue without repeating.```"
        9.  **Path Referencing:** Append ", it is in the repo." to file paths when instructing Task AIs.
        10. **Risk Assessment Directive:** "For each commit, assess risk (Low, Medium, High) based on scope, complexity, impact, test coverage, dependencies. Include in commit message: `[RISK_ASSESSMENT]` block with `- Risk-Level: <level>` and `- Justification: <explanation>` in `Notes-To-Next-Jules`."
        11. **Append Selected Add-ons:**
            a.  Retrieve `Inheritable_Addons_Content_Ordered_List` (populated by Core Instructions Section I.D.5).
            b.  For each `add_on_content_string` in this list:
                i.  **Resolve Placeholders:** Within `add_on_content_string`, replace the following placeholders with their corresponding resolved values:
                    *   `[Actual Path to Prompts Folder]` with `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/` (Note: this placeholder itself might be deprecated in add-ons, prefer more specific ones like those below or ones that resolve to `/promptu/core/` for core items like `base_iep.txt`)
                    *   `[Actual User-Specified Path for Submodule Plans]` with `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Submodule_Plans_Subdir]/`
                    *   `[Actual User-Specified Task Output Base Path]` with `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Artifacts_Subdir]/`
                    *   `[Project Name Placeholder]` with `Resolved_DP_Project_Name`
                    *   `[Iteration Placeholder XX]` with `Resolved_DP_Iteration_ID`
                    *   (Define other common placeholder mappings as necessary if they are used in inheritable add-ons.)
                    *   **Specific to `create_research_report` add-on when appended for a worker task:**
                        *   `[Worker_Task_Specific_KB_Output_Path_Placeholder]` MUST be resolved to a unique path for that worker's research output (e.g., `[Resolved_DP_Project_KB_Path]task_[WorkerTaskID]_research/`, where `[WorkerTaskID]` is derived from the task's filename like `p<Phase#_t<Task#`).
                        *   `[Worker_Task_Specific_Domain_Name_Placeholder]` MUST be resolved to a unique domain name for that worker's research (e.g., `[Resolved_DP_Project_Name]_Task_[WorkerTaskID]_Research`).
                        *   `[Shared_Master_Domain_Log_Path_Placeholder]` MUST be resolved to `Resolved_DP_Master_Domain_Log_Path`.
                        *   When `dev_planner` constructs the `[[USER_CONFIG_FOR_create_research_report]]` block *for a worker task's prompt*, it MUST use these resolved values for the corresponding parameters (`EXPERT_CONTENT_PATH`, `REFERENCE_LIST_PATH`, `RESEARCH_REPORT_OUTPUT_PATH` should use the unique worker path; `MASTER_DOMAIN_LOG_PATH` should use the shared path; `DOMAIN_NAME_FOR_LOG` should use the unique worker domain name).
                ii. Append the placeholder-resolved `add_on_content_string` to the current task prompt.

C.  **Supporting Documentation (Task Spawning Specific):**
    1.  **`00_task_launch_plan.md`:** (Note: Generation of `information_exchange_protocol.md` is handled by Core Instructions Section III.C.1, which should place it in `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/`)
        *   Create based on template. Dynamically replace placeholders.
        *   **Location:** `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/00_task_launch_plan.md`.
        *   **Launch Commands Path Logic:** Task prompt paths for launch commands will be like `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/p1_t1_example.txt`. Ensure these are correctly constructed relative to the repository root.
        *   **Missing Add-on Warnings:** If add-ons from `[[USER_ADDON_SELECTION]]` (parsed by Core Instructions Section I.D) were not found, include the warning message (provided by logic in Core Instructions I.D.4.d) at the top of TLP.
        *   **TLP TEMPLATE:**
            \`\`\`markdown
            # Task Launch Plan for [Resolved_DP_Project_Name] - Iteration [Resolved_DP_Iteration_ID]

            **Overall Planning Confidence:** <High | Medium | Low (P-AI to populate)>
            **Confidence Rationale:** <P-AI to provide a brief explanation...>

            ---
            ## Visual Plan Overview
            \`\`\`mermaid
            [[[P-AI TO GENERATE MERMAID FLOWCHART DIAGRAM HERE]]]
            graph TD; A["T1"] --> B["T2"];
            \`\`\`
            *(Diagram above is placeholder...)*

            [[[P-AI TO INSERT WARNINGS ABOUT MISSING ADD-ONS HERE, IF ANY]]]

            ---
            ## 1. Overview
            Welcome...
            **Key Files & Folders (relative to repo root):**
            *   Task Prompts, TLP, IEP: `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/`
            *   Inter-AI Communication (IPC): `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/ipc/`
            *   Task Sub-Development Plans (`dev_plan.md`, `next_steps.md`): `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Submodule_Plans_Subdir]/`
            *   Task Output Artifacts: `[Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Artifacts_Subdir]/`
            ## 2. Execution Workflow
            1. Review Phases...
            2. Parallel Task Execution: ...unless "Dependencies" field indicates sequence...
            ...
            ## 3. Launching Tasks
            ---
            [[YOU MUST DYNAMICALLY GENERATE THE TASK LISTING BELOW]]
            [[FOR EACH PHASE:]]
            ### **Phase <Num> Tasks**
            *(Respect "Dependencies" for sequencing)*
            [[FOR EACH TASK:]]
            #### **Task: `<Full Prompt Filename>`**
            *   **Description:** <1-2 sentence objective>
            *   **Estimated Effort:** <S|M|L|XL>
            *   **Dependencies:** <(P-AI Populates if Applicable)...>
            *   **Initial Launch:** \`\`\`[Path to Prompt File relative to Repo Root, e.g., [Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/<Full Prompt Filename>] is the prompt, it is in the repo.\`\`\`
            *   **Retry if Crashed:** \`\`\`[Path to Prompt File relative to Repo Root, e.g., [Resolved_DP_Base_Output_Path]/[Resolved_DP_Task_Prompts_Subdir]/<Full Prompt Filename>] is the prompt, ...continue task.\`\`\`
            ---
            [[END OF DYNAMIC TASK LISTING]]
            ## 4. Iteration Completion
            Review `_next_steps.md`... Good luck!
            \`\`\`
            (End of 00_task_launch_plan.md template)

**IV. FINAL INSTRUCTION TO PLANNING AI & SELF-CORRECTION (Specific to Task Spawning):**
A. **Planning AI Self-Correction and Verification Checks (MANDATORY):**
    Before finalizing, perform these checks on *each generated task prompt*:
    1. Core Directives: `dev_plan.md`? `next_steps.md` (with `### Key Learnings & Discoveries`)? IEP reminder? Risk Assessment directive? Retry Logic?
    2. Path Placeholders: All paths constructed correctly using `Resolved_DP_...` parameters (from Section I of this add-on)? Specific output subdirectories like `<PhaseTaskName>` correctly appended where necessary? Paths have ", it is in the repo."?
    3. Selected Add-on Inclusion: Logic for `Inheritable_Addons_Content_Ordered_List` (from Core Instructions Section I.D.5) applied? Selected add-ons appended with internal placeholders resolved according to mappings in Section III.B.11.b.i of this add-on?
    4. Clarity: Task Overview & Instructions clear?
    5. Dependency Statement: Coherent if task is dependent?
    Correct any discrepancies.

**IV. OPERATIONAL MODES OVERVIEW**

Beyond the primary planning workflows (Monolithic, DelegatedPlanning, HybridIterative) detailed in Section II, `dev_planner` can be invoked by an orchestrator (like `PromptuDev_AI`) in specific modes to support the "Iterative Phased Development Process." When invoked in these modes, the goal provided by the orchestrator will be paramount, and certain sections of the standard planning process may be bypassed or modified.

**V. ACCEPTANCE ANALYSIS MODE**

A.  **Trigger:** Invoked by an orchestrator (e.g., `PromptuDev_AI`) with a specific goal like "Perform Phase Acceptance Analysis for Phase X."
B.  **Inputs (Expected from Orchestrator/`handoff_notes.md`):**
    1.  `Current_Phase_ID` (or similar identifier for the phase being analyzed).
    2.  A clear list of, or paths to, the actual merged deliverables produced by the user/developer Task AIs for this phase.
    3.  The original detailed plan for `Current_Phase_ID` (e.g., the `[PhaseID]_submodule_dev_plan.md` or the main plan if monolithic for that phase) which contains the objectives, tasks, and acceptance criteria.
    4.  Access to `Resolved_DP_Project_Specifications_Ref` for cross-referencing.
C.  **Logic:**
    1.  For each task/objective/deliverable defined in the original phase plan:
        a.  Compare the actual deliverable(s) against the planned item and its acceptance criteria.
        b.  Verify adherence to relevant sections of `Resolved_DP_Project_Specifications_Ref`.
        c.  Determine status: "Accepted," "Rejected," or "Incomplete."
D.  **Output: "Acceptance Analysis Report"**
    1.  Generate a new Markdown document (e.g., `[Current_Phase_ID]_acceptance_analysis_report.md`) in `Resolved_DP_Submodule_Plans_Subdir`.
    2.  **Structure:**
        *   **Overall Phase Summary:** Brief statement of acceptance status (e.g., "All items accepted," "X items rejected, Y incomplete," etc.).
        *   **Detailed Item Breakdown:** For each planned task/deliverable:
            *   **Planned Item:** Description from original plan.
            *   **Deliverable(s) Provided:** Link(s) to actual deliverable(s).
            *   **Status:** Accepted | Rejected | Incomplete.
            *   **Analysis & Justification:** Detailed reasons for the status, especially for "Rejected" or "Incomplete." Cite specific deviations from plan or specifications. Include evidence if applicable.
            *   **Recommendations (for Rejected/Incomplete):** Brief suggestions for remediation if obvious.
    3.  This report is then passed back to the orchestrator.

**VI. REMEDIATION PLANNING MODE**

A.  **Trigger:** Invoked by an orchestrator (e.g., `PromptuDev_AI`) with a specific goal like "Create Phase Remediation Plan for Phase X based on Acceptance Analysis Report."
B.  **Inputs (Expected from Orchestrator/`handoff_notes.md`):**
    1.  `Current_Phase_ID` (for the phase requiring remediation).
    2.  The "Acceptance Analysis Report" (generated in Section V) detailing rejected/incomplete items.
    3.  Access to the original phase plan and `Resolved_DP_Project_Specifications_Ref`.
C.  **Logic:**
    1.  For each "Rejected" or "Incomplete" item from the Acceptance Analysis Report:
        a.  Analyze the reasons for rejection/incompleteness.
        b.  Define a set of focused, corrective tasks needed to address the deficiencies. These tasks should be granular enough for clear execution.
        c.  These corrective tasks might involve debugging existing code, creating missing documentation, re-implementing a feature to meet specifications, etc.
    2.  These new corrective tasks essentially form a new, scoped-down "mini-plan" or addendum to the original phase plan.
D.  **Output: "Remediation Task Launch Plan"**
    1.  Generate a new Task Launch Plan (TLP) document (e.g., `[Current_Phase_ID]_remediation_tlp.md`) in `Resolved_DP_Task_Prompts_Subdir`.
    2.  This TLP should list:
        *   A clear reference to the `Current_Phase_ID` being remediated.
        *   A summary of the items from the Acceptance Analysis Report that this remediation plan addresses.
        *   A new set of task prompts (following structure in Section III.B) for each corrective task identified in VI.C.1. These prompts should be clearly marked as "Remediation Task for [Original Task ID/Objective]".
    3.  This Remediation TLP is then passed back to the orchestrator to re-enter the user execution and subsequent acceptance analysis cycle for these specific remediation tasks. The goal is to bring the phase to full acceptance.

**VII. FINAL INSTRUCTION TO PLANNING AI & SELF-CORRECTION (Specific to Task Spawning):**
(Note: Final Commit Message by Planning AI is handled by Core Instructions Section IV.B)
