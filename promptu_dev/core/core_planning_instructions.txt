**I. USER-CONFIGURED PATHS, ADD-ON SELECTION, COMPONENT DISCOVERY & LOADING:**

A. **Determine Invocation Mode (Developer or User):**
    1.  Initialize `Is_Developer_Session = false`.
    2.  Assume the AI execution environment provides a variable or can determine the full path of the initially processed directive file (e.g., the file specified in `[[PROCESS_FRAMEWORK_INSTRUCTIONS FROM /path/to/file.txt]]`). Let this be `Initial_Directive_File_Path`.
    3.  If `Initial_Directive_File_Path` ends with `promptu_dev/promptu_dev.txt`:
        Set `Is_Developer_Session = true`.
        INFO "Developer Mode detected based on invocation path."
    4.  Else:
        INFO "User Mode detected (or default)."
    5.  This `Is_Developer_Session` flag will be used to determine paths for certain meta-files like handoff notes.

B. **Core Framework Principle: Contextual AI Operation:**
    1.  A fundamental design principle of the Promptu framework is to enable AI instances that can effectively create, recall, and utilize CONTEXT.
    2.  CONTEXT encompasses the specific goals of a task, the state of the codebase, historical decisions (e.g., from handoff notes or previous plan iterations), user-provided information, selected tools/add-ons, and the AI's own operational directives (like those in Section IV).
    3.  All components and instructions within this framework should strive to provide, process, and maintain relevant context to enhance AI effectiveness and ensure coherent, goal-oriented behavior.

C. **Extract User's High-Level Project Request:**
    1.  Initialize `User_High_Level_Project_Goal`: `null` (or an empty string).
    2.  Define delimiters: `start_req_delim = "[[USER_PROJECT_REQUEST]]"`, `end_req_delim = "[[END_USER_PROJECT_REQUEST]]"`.
    1.  Search the *entire current processing content* (which the AI system is assumed to have prepared by combining the user's initial raw request with the user's configured `post_promptu.txt` file loaded via a directive) for text between these delimiters.
    4.  If found:
        a.  Extract the raw string content (exclusive of the delimiters, trim leading/trailing whitespace).
        b.  Store this extracted content as `User_High_Level_Project_Goal`.
        c.  INFO "User High-Level Project Goal successfully extracted."
    5.  If not found OR if the extracted content is empty or only whitespace:
        a.  WARNING "[[USER_PROJECT_REQUEST]] block not found or empty. The primary project goal may be missing. Subsequent planning processes might rely on user input provided through other configuration means (e.g., within component-specific parameters) or may require clarification."
        b.  `User_High_Level_Project_Goal` remains `null` or is set to a specific "not_found_or_empty" marker string.
    6.  The `User_High_Level_Project_Goal` (or its not-found status) should be accessible by primary directive components (e.g., the component for a selected promptApp task, or a selected primary add-on like `task_spawning_addon` or `create_research_report`) for their main planning or processing context. These components will be responsible for checking if the goal is sufficiently defined for their needs.

D. **Parse User-Configured Paths for Outputs and Specific Inputs:**
    You **must** parse the `[[USER PATH CONFIGURATION]]` block if it is found at the very beginning of *this `post_promptu.txt`*. These paths are primarily for directing your outputs and locating some user-provided process-specific inputs.
    *   **Note:** This section is largely deprecated with the move to app-specific configurations and fixed system paths. However, if legacy path configurations are found, they might be used by older components. Modern components should rely on their own `user_..._config.txt` files for path parameters.
    *   If any output/process-specific paths are required by an active component and not found in its dedicated configuration, that component must define its own default behavior or error handling.
    *   All paths you generate for outputs must be constructed clearly, typically relative to the repository root.

E. **Fixed Global System Paths for Core Components:**
    The locations for core framework components (PromptApps, Add-ons, Utils, Base IEP, IPC directory) are fixed and relative to the repository root. You **must** use these hardcoded paths for discovery and loading:
    *   **PromptApps Base Directory:** `promptu/components/apps/`
    *   **Add-ons Base Directory:** `promptu/components/add_ons/`
    *   **Utils Base Directory:** `promptu/components/utils/`
    *   **IEP Base Directory:** `promptu/core/` (specifically for `base_iep.txt`)
    *   **IPC Base Directory:** `promptu/ipc/` (for future IPC components and general IPC file storage)

F. **Discover and Load Add-on Components:**
    1.  **Parse User Add-on Selections:**
        a.  Scan the `[[USER_ADDON_SELECTION]]` block from `post_promptu.txt`.
        b.  Identify lines beginning with `[x]` to extract the selected `addon_app_name`s (these are folder names).
        c.  Compile an ordered list of these: `Selected_Addons_AppNames_Ordered`.
    2.  **Define Known Primary Directive Add-on Apps:**
        `Known_Primary_Directive_Addon_Apps`: A list of `addon_app_name`s recognized as primary directives (e.g., `["dev_planner", "create_research_report"]`).
    3.  **Initialize Collections for Add-ons:**
        *   `Active_Primary_Addon_AppName`: null
        *   `All_Selected_Addons_Content_Map`: An empty map for `addon_app_name: primary_instruction_content`.
        *   `App_Specific_Configs_Content_Map`: An empty map for `component_name: raw_config_block_string`. (Note: This map is now generic for any component type, not just add-ons).
        *   `Inheritable_Addons_Content_Ordered_List`: An empty ordered list for content of selected non-primary add-ons.
        *   `Loaded_Primary_Addon_AppNames`: An empty list to track selected primary add-on apps that were successfully loaded.
    4.  **Load Selected Add-on Content & Discover App-Specific Configs:**
        For each `selected_app_name` in `Selected_Addons_AppNames_Ordered`:
        a.  Construct the path to its primary instruction file: `path_to_primary_instruction_file = promptu/components/add_ons/[selected_app_name]/[selected_app_name].txt`.
        b.  Attempt to read the content of this file.
        c.  If successfully read:
            i.  Store its content in `All_Selected_Addons_Content_Map` with `selected_app_name` as key.
            ii. If `selected_app_name` is in `Known_Primary_Directive_Addon_Apps`:
                *   Add `selected_app_name` to `Loaded_Primary_Addon_AppNames`.
                *   If `Active_Primary_Addon_AppName` is still null, set `Active_Primary_Addon_AppName = selected_app_name`.
            iii. **Scan Main Prompt for App-Specific Configuration Block:**
                *   Define delimiters: `start_delim = "[[USER_CONFIG_FOR_" + selected_app_name + "]]"`, `end_delim = "[[END_USER_CONFIG_FOR_" + selected_app_name + "]]"`.
                *   Search the *entire original user-provided main prompt file content* (typically `post_promptu.txt`) for text between these delimiters.
                *   If found, extract the raw string content and store it in `App_Specific_Configs_Content_Map` with `selected_app_name` as the key.
        d.  If the primary instruction file is not found or unreadable: Prepare a warning: "Warning: Selected add-on app '[selected_app_name]' is missing its primary instruction file at '[path_to_primary_instruction_file]' and will be skipped."
    5.  **Populate Inheritable Add-ons List:** (This logic will be primarily driven by promptApp context or if no promptApp is selected)
        For each `loaded_app_name` in `Selected_Addons_AppNames_Ordered` (iterate based on original selection order, but only consider apps successfully loaded):
        a.  If `loaded_app_name` is NOT equal to `Active_Primary_Addon_AppName` (and no promptApp is active, or if promptApp allows), add its content to `Inheritable_Addons_Content_Ordered_List`.
    6.  **Handle Multiple Selected Primary Add-ons:** If `Loaded_Primary_Addon_AppNames` contains more than one app name, prepare a warning.
    7.  The collections are used in Section II.

G. **Input Definition Files (base_iep.txt):**
    Loaded from `promptu/core/base_iep.txt`. (Referenced in Section III.C.1).

H. **Discover and Load Utility Components ("Utils"):**
    a.  Initialize `All_Available_Utils_Content_Map` (map for `util_app_name: content`).
    b.  Scan for all subdirectories within `promptu/components/utils/`. For each `util_dir_name`:
        i.  Define `util_app_name = util_dir_name`.
        ii. Path to component: `path_to_util = promptu/components/utils/[util_dir_name]/[util_dir_name].txt`.
        iii. Attempt to load content from `path_to_util`. If successful, store it in `All_Available_Utils_Content_Map` with `util_app_name` as key and mark this `util_app_name` as "loaded_from_subdir".
    c.  Scan for all `.txt` files directly within `promptu/components/utils/` (e.g., `utility_name.txt`). For each `util_file_name.txt`:
        i.  Define `util_app_name = util_file_name` (without the .txt extension).
        ii. If `util_app_name` is already in `All_Available_Utils_Content_Map` (i.e., "loaded_from_subdir"), issue a warning: "Warning: Utility '[util_app_name]' found both as direct file `promptu/components/utils/[util_file_name].txt` and in subdirectory `promptu/components/utils/[util_app_name]/`. Prioritizing version from subdirectory. Please ensure uniqueness." and SKIP this file.
        iii. Else:
            *   Path to component: `path_to_util = promptu/components/utils/[util_file_name].txt`.
            *   Attempt to load content from `path_to_util`. If successful, store it in `All_Available_Utils_Content_Map` with `util_app_name` as key.
    d.  For any util not loaded successfully (either type), issue appropriate warnings.
    e.  Utils are available for use by other components.

I. **Discover and Load PromptApp Manifests:**
    1.  Initialize `Available_PromptApps_Manifest_Map` (empty map for `promptAppName: manifest_object`).
    2.  Scan `promptu/components/apps/` for subdirectories. Each is a `promptAppName`.
    3.  For each `promptAppName`:
        a.  Path to manifest: `promptu/components/apps/[promptAppName]/[promptAppName]_manifest.json`.
        b.  Attempt to read and parse the JSON content of this file.
        c.  If successfully read and parsed:
            i.  Validate manifest structure (presence of `promptAppDisplayName`, `description`, `phases` array; phases have `phaseName`, `tasks` array; tasks have `taskName`, `description`, `componentName`, `isIterable`). Issue warnings for structural issues.
            ii. Store the valid manifest object in `Available_PromptApps_Manifest_Map` with `promptAppName` as key.
        d.  If manifest file is missing, unreadable, or JSON is invalid: Prepare a warning: "Warning: PromptApp '[promptAppName]' has a missing or invalid manifest at '[path_to_manifest]' and will be unavailable."

J. **Parse User PromptApp Selection & Configuration:**
    1.  Initialize `Selected_PromptAppName`: null.
    2.  Initialize `Selected_App_Tasks_Ordered`: empty list.
    3.  Scan `post_promptu.txt` for the `[[USER_APP_SELECTION]]` block.
    4.  Identify lines beginning with `[x]` to extract the selected `potential_app_name`.
    5.  If multiple promptApps are selected, issue a warning: "Warning: Multiple promptApps selected. Using the first one: '[first_selected_app_name]'." Set `Selected_PromptAppName` to the first valid one found in `Available_PromptApps_Manifest_Map`.
    6.  If only one `[x]` is found, set `Selected_PromptAppName` to that `potential_app_name`, provided it exists as a key in `Available_PromptApps_Manifest_Map`. If not found in the map, issue a warning and set `Selected_PromptAppName` to null.
    7.  If `Selected_PromptAppName` is set and valid:
        a.  Define delimiters for its configuration block: `start_config_delim = "[[USER_" + Selected_PromptAppName + "_CONFIGURATION]]"`, `end_config_delim = "[[END_USER_" + Selected_PromptAppName + "_CONFIGURATION]]"`.
        b.  Search the *entire original user-provided main prompt file content* (typically `post_promptu.txt`) for text between these delimiters.
        c.  If found:
            i.  Parse the content line by line.
            ii. Identify lines starting with `[x]` (case-insensitive for 'x') followed by a task name (e.g., `[x] My Task Name`). Extract "My Task Name".
            iii. Add each such extracted task name to `Selected_App_Tasks_Ordered`, maintaining the order from the block.
            iv. Store the raw string content of this block in `App_Specific_Configs_Content_Map` with `Selected_PromptAppName` as the key (for reference or audit).
        d.  If the configuration block is missing: Issue a warning: "Warning: PromptApp '[Selected_PromptAppName]' is selected, but its configuration block '[[USER_[Selected_PromptAppName]_CONFIGURATION]]' was not found. No tasks can be run." Set `Selected_PromptAppName` to null.
        e.  If the block is found but no tasks are checked `[x]`: Issue a warning: "Warning: PromptApp '[Selected_PromptAppName]' configuration block found, but no tasks were selected with '[x]'. No tasks will be run." Set `Selected_PromptAppName` to null.
    8.  **If a PromptApp is being executed (`Selected_PromptAppName` is determined and valid):**
        a.  The Aidentity MUST invoke `Trait_Core_GenerateAppInstanceID` to generate and store `session.AppInstanceID`.
        b.  The Aidentity MUST invoke `Trait_Core_ManageAppHandoffNote.create_app_handoff_note` using `session.AppInstanceID` and `Selected_PromptAppName` to create the initial app-specific handoff note.

K. **Parse User Framework Settings:**
    1.  Initialize `Framework_Full_Handoff_Notes_Enabled`: `false`.
    2.  Define delimiters for the framework settings block: `start_fs_delim = "[[USER_FRAMEWORK_SETTINGS]]"`, `end_fs_delim = "[[END_USER_FRAMEWORK_SETTINGS]]"`.
    3.  Search the *entire original user-provided main prompt file content* (typically the user's configured copy of `post_promptu.txt`) for text between these delimiters.
    4.  If the `[[USER_FRAMEWORK_SETTINGS]]` block is found:
        a.  Within the extracted block content, search for a line that looks like a checkbox for "Full_Handoff_Notes_Logging_Enabled". This typically means a line starting with `[x]` (case-insensitive for 'x') or `[ ]`, followed by the text `Full_Handoff_Notes_Logging_Enabled`.
        b.  If such a line is found and it starts with `[x]` (indicating checked):
            Set `Framework_Full_Handoff_Notes_Enabled = true`.
            INFO "Full_Handoff_Notes_Logging_Enabled is TRUE."
        c.  Else (if found but not `[x]`, or if the specific checkbox line is not found within the block):
            `Framework_Full_Handoff_Notes_Enabled` remains `false`.
            INFO "Full_Handoff_Notes_Logging_Enabled is FALSE (default or explicitly unchecked)."
    5.  Else (if the `[[USER_FRAMEWORK_SETTINGS]]` block itself is not found):
        `Framework_Full_Handoff_Notes_Enabled` remains `false`.
        INFO "[[USER_FRAMEWORK_SETTINGS]] block not found. Full_Handoff_Notes_Logging_Enabled is FALSE (default)."

**II. PRIMARY EXECUTION LOGIC (Revised for PromptApps):**

A. **Determine Execution Path (PromptApp or Add-on):**

    -1. Initialize Handoff Notes Archive and Context:
        a. Define paths based on `Is_Developer_Session` (from I.A):
           IF `Is_Developer_Session` is true:
               `handoff_notes_path = "promptu_dev/aidentity/handoff_notes.md"`
               `handoff_archive_dir = "promptu_dev/aidentity/archive/"`
               `handoff_notes_archive_subdir = handoff_archive_dir + "handoff_notes/"`
               INFO "Using Developer handoff paths."
           ELSE (User Mode):
               `handoff_notes_path = "promptu/aidentity/handoff_notes.md"`
               `handoff_archive_dir = "promptu/aidentity/archive/"`
               `handoff_notes_archive_subdir = handoff_archive_dir + "handoff_notes/"`
               INFO "Using User handoff paths."
        b. Check if `handoff_notes_path` exists and has content from a *previous session* (e.g., its modification timestamp is not from the current session or it's not empty at the very start of your lifecycle).
        c. If yes:
            i. Read its content (`stale_notes_content`).
            ii. Generate a `session_date_time` marker (e.g., YYYYMMDD_HHMMSS).
            iii. Ensure `handoff_notes_archive_subdir` exists in the workspace. If `handoff_archive_dir` or `handoff_notes_archive_subdir` do not exist, create them.
            iv. Define `archive_file_path = handoff_notes_archive_subdir + "handoff_notes_" + session_date_time + ".md"`.
            v. Create `archive_file_path` and write `stale_notes_content` into it.
            vi. Empty `handoff_notes_path` in the workspace (e.g., by writing an empty string to it or truncating it).
        d. Read all files from `handoff_notes_archive_subdir` for historical context. This is to ensure you have past handoff information available.
        e. Read the (now potentially empty) `handoff_notes_path` to load any notes that might have been added in the current session startup phase, if applicable.

    0.  **Determine Invocation Context and Handle Special Empty States:**
        *   Assume a variable `Invocation_Context` is available, set by the system to either 'PRE_PROMPTU' (if `pre_promptu.txt` is the entry point) or 'POST_PROMPTU' (if `post_promptu.txt` is the entry point). If unavailable, default to 'POST_PROMPTU' and issue a warning.
        *   Check `User_High_Level_Project_Goal` (from Section I.C), `Selected_PromptAppName` (from Section I.I), `Active_Primary_Addon_AppName` (from Section I.F), and `Inheritable_Addons_Content_Ordered_List` (from Section I.F).
        *   **Scenario 1 (pre_promptu with no request):**
            *   IF `Invocation_Context` is 'PRE_PROMPTU' AND (`User_High_Level_Project_Goal` is null OR `User_High_Level_Project_Goal` is empty_or_whitespace_marker):
                *   INFO: 'pre_promptu.txt' invoked without a user project request.
                *   INSTRUCT AI: 'Your primary task is to engage the user in a discussion to elicit their requirements or the objectives they wish to achieve with pre-processing utilities. Ask open-ended questions to understand their needs. Do not proceed with any utility selections from `[[USER_UTIL_SELECTION]]` in `pre_promptu.txt` until these initial requirements are clarified. HALT further framework processing and await user interaction.'
                *   RETURN (do not proceed to normal execution logic).
        *   **Scenario 2 (post_promptu with no request, no app, no add-ons):**
            *   ELSE IF `Invocation_Context` is 'POST_PROMPTU' AND (`User_High_Level_Project_Goal` is null OR `User_High_Level_Project_Goal` is empty_or_whitespace_marker) AND `Selected_PromptAppName` is null AND `Active_Primary_Addon_AppName` is null AND `Inheritable_Addons_Content_Ordered_List` is empty:
                *   INFO: 'post_promptu.txt' invoked without a user project request and no apps or add-ons selected.
                *   INSTRUCT AI: 'The framework was invoked without a specific project request or any selected app or add-on. Your task is to engage the user in a discussion to elicit their project requirements or what they intended to do. Ask open-ended questions to understand their project goals or if they need guidance on using the framework. HALT further framework processing and await user interaction.'
                *   RETURN (do not proceed to normal execution logic).
        *   **Scenario 3 (post_promptu with no request, but app selected):**
            *   ELSE IF `Invocation_Context` is 'POST_PROMPTU' AND (`User_High_Level_Project_Goal` is null OR `User_High_Level_Project_Goal` is empty_or_whitespace_marker) AND `Selected_PromptAppName` is not null AND `Available_PromptApps_Manifest_Map` contains `Selected_PromptAppName` AND `Selected_App_Tasks_Ordered` is not empty:
                *   INFO: 'post_promptu.txt' invoked without a user project request, but a promptApp '[Selected_PromptAppName]' is selected. Proceeding with promptApp execution.
                *   (Fall through to the existing promptApp execution logic, which will begin at step II.A.1. The selected promptApp component will be responsible for handling the missing `User_High_Level_Project_Goal` if it's critical for its operation.)
        *   ELSE:
            *   INFO: Proceeding with standard execution path.
            *   (Fall through to existing logic at step II.A.1)

    1.  **IF `Selected_PromptAppName` is set AND `Available_PromptApps_Manifest_Map` contains `Selected_PromptAppName` AND `Selected_App_Tasks_Ordered` is not empty:**
        a.  **PromptApp Execution Path:**
            i.   INFO "Executing selected promptApp: [Selected_PromptAppName]".
            ii.  Get the manifest: `current_app_manifest = Available_PromptApps_Manifest_Map[Selected_PromptAppName]`.
            iii. Identify the *first task name* from `Selected_App_Tasks_Ordered`. Let this be `current_task_user_name`.
            iv.  Find `current_task_info` from `current_app_manifest.phases.tasks` where `task.taskName` matches `current_task_user_name`.
            v.   If `current_task_info` is not found in the manifest: CRITICAL ERROR "Selected task '[current_task_user_name]' for promptApp '[Selected_PromptAppName]' not found in its manifest. Halting." HALT.
            vi.  Let `component_name_to_load = current_task_info.componentName`.
            vii. INFO "Current promptApp task: '[current_task_user_name]' using component: '[component_name_to_load]'".

            viii. **Component Resolution (Search Order - App-Specific First):**
                *   Path Attempt 1 (App-Local Flat File Style): `path_to_component = promptu/components/apps/[Selected_PromptAppName]/[component_name_to_load].txt`
                *   Path Attempt 2 (App-Local Folder Style): `path_to_component = promptu/components/apps/[Selected_PromptAppName]/[component_name_to_load]/[component_name_to_load].txt` (if not found in app-local flat file)
                *   Path Attempt 3 (Add-on): `path_to_component = promptu/components/add_ons/[component_name_to_load]/[component_name_to_load].txt` (if not found previously)
                *   Path Attempt 4 (Util): `path_to_component = promptu/components/utils/[component_name_to_load]/[component_name_to_load].txt` (if not found previously)
                *   If component file not found after all attempts: CRITICAL ERROR "Component '[component_name_to_load]' for task '[current_task_user_name]' in promptApp '[Selected_PromptAppName]' not found. Search paths were: [list attempted paths]. Halting." HALT.

            ix.  **Load Component & Its Config:**
                *   Read the `component_instruction_content` from the resolved `path_to_component`.
                *   Determine `base_path_of_resolved_component` (e.g., `promptu/components/add_ons/[component_name_to_load]/` or `promptu/components/apps/[Selected_PromptAppName]/`).
                *   Read `user_component_config_content` from `[base_path_of_resolved_component]user_[component_name_to_load]_config.txt`. (Handle file not found gracefully for components that don't have one).
                *   Get `main_prompt_component_config_block_content` from `App_Specific_Configs_Content_Map[component_name_to_load]` (this was populated in I.D.4.c.iii if a `[[USER_CONFIG_FOR_componentName]]` block exists in the main prompt).

            x.   **Parameter Resolution for the Component:**
                *   (This adapts the detailed loop previously in add-on logic, like `build_product_specs_process` or `create_research_report` Phase 1).
                *   The component's `user_..._config.txt` defines expected parameters, their Requirement, DefaultType, Description, and Default value.
                *   For each parameter defined in `user_component_config_content`:
                    1.  Value from `main_prompt_component_config_block_content` (parsed from `[[USER_CONFIG_FOR_component_name_to_load]]`).
                    2.  User-edited value in `user_component_config_content` (parsed from `[USER_VALUE_START]...[USER_VALUE_END]`).
                    3.  Value from `current_task_info.defaultConfigOverrides[ParameterName]` (from `promptApp` manifest for the current task).
                    4.  Accepted default value in `user_component_config_content` (from `# Default: [value]` if `DefaultType: Accepted`).
                    5.  If still unresolved & `Requirement: Required` & `DefaultType: Placeholder`: AI must ask user for value via chat. Update the on-disk `user_..._config.txt` and advise user to update their main prompt's `[[USER_CONFIG_FOR_...]]` block.
                    6.  If still unresolved & `Requirement: Required`: CRITICAL ERROR "Required parameter '[ParameterName]' for component '[component_name_to_load]' could not be resolved. Halting." HALT.
                *   Store resolved parameters internally for the component's use.

            xi.  **Execute Component's Instructions:** Execute the `component_instruction_content` using its resolved parameters.

            xi.  **Execute Component's Instructions:**
                *   **Conceptual Steps for Hierarchical Handoff (to be detailed in `Trait_Core_ExecutePromptAppPath.md`):**
                    *   **Before actual execution:**
                        1.  Invoke `Trait_Core_GenerateComponentInstanceID` (providing `session.AppInstanceID`, `component_name_to_load`, `current_task_user_name`/index) to obtain a unique `Current_ComponentInstanceID`.
                        2.  Inject `Current_ComponentInstanceID` into the component's configuration parameters (e.g., by adding it to the `defaultConfigOverrides` map before final parameter resolution for the component).
                        3.  Invoke `Trait_Core_ManageAppHandoffNote.record_component_invocation` (using `session.AppInstanceID`, `Selected_PromptAppName`, `Current_ComponentInstanceID`, `component_name_to_load`, initial status like "Invoking", and current timestamp) to log this component's invocation in the current app's specific handoff note.
                *   Execute the `component_instruction_content` using its resolved parameters.
                *   **After component execution or status update (e.g., if it HALTs for resumption or completes):**
                    1.  Invoke `Trait_Core_ManageAppHandoffNote.update_component_status_in_app_handoff` (using `session.AppInstanceID`, `Selected_PromptAppName`, `Current_ComponentInstanceID`, and the new component status) to update the component's status in the app's specific handoff note.

            xii. **Iteration Handling (if `current_task_info.isIterable` is true):**
                *   The executed component is expected to contain logic that, upon its own completion, prompts the user with options like "repeat this task" or "move on to the next task".
                *   If user chooses "move on": The component's instructions should lead to the AI outputting a message like: "Task '[current_task_user_name]' of promptApp '[Selected_PromptAppName]' is complete. To proceed, please reconfigure your main prompt to select the next task: '[Name of next task in Selected_App_Tasks_Ordered, if any; else "No further tasks selected in the current promptApp configuration."]' and then start a new AI session." Then the AI should HALT.
                *   (The MPS framework itself does not manage the task-to-task transition beyond this instruction; user re-invocation with an updated prompt is required for the next task in the `promptApp`.)

    2.  **ELSE (No PromptApp selected or no actionable tasks in it; fallback to Add-on logic):**
        a.  INFO "No active promptApp. Proceeding with add-on execution logic."
        b.  **Process Active Primary Add-on (if any):** (This is the existing Section II.A logic)
            i.  If `Active_Primary_Addon_AppName` (identified in I.F.4) is not null:
                *   Retrieve its primary instruction content from `All_Selected_Addons_Content_Map`.
                *   Retrieve its app-specific config string from `App_Specific_Configs_Content_Map[Active_Primary_Addon_AppName]`.
                *   Execute its instructions. The add-on parses its config string and uses `Inheritable_Addons_Content_Ordered_List`.
            ii. **Else (If `Active_Primary_Addon_AppName` IS NULL):** (This is the existing Section II.B logic)
                *   State no active primary add-on was selected/found.
                *   If `Inheritable_Addons_Content_Ordered_List` is not empty, state intent to process these. For each, retrieve its app-specific config string. Execute if self-executing; be cautious.
                *   Generate `information_exchange_protocol.md`.
                *   Conclude operations.

**III. OUTPUT GENERATION REQUIREMENTS (Core Utilities):**

C. **Supporting Documentation (Core Utilities):**
1.  **`information_exchange_protocol.md`:**
    *   (Condition for generation as before, typically if no primary add-on or promptApp task successfully runs to completion of a major process).
    *   Load from `promptu/core/base_iep.txt`.
    *   Create in 'promptu folder' (user-configured output path, or a default like `outputs/current_session_prompts/`).
    *   (Example filenames for other docs: `dev_plan.md`, `mps_usage_guide.md`)

**III.D. Handoff Note Content and Structure (Governed by `Trait_Core_AIdentity_UpdateHandoffNotes.md`)**

    1.  **General Structure:** The main `handoff_notes.md` file, updated at the end of each session, should follow a consistent structure. This includes session summary, key activities, and focus for the next instance.
    2.  **`### Active and Recent Tasks` Section:**
        a.  This section is critical for maintaining context on ongoing work, especially for hierarchical task management involving PromptApps and their components.
        b.  It should list the main AI's current direct task (if any).
        c.  **Active PromptApp Instance:** If a PromptApp is active or was active during the session:
            i.  Display the `AppName` and its `session.AppInstanceID`.
            ii. Provide a link to its app-specific handoff note (e.g., `promptu_dev/aidentity/archive/apps/[session.AppInstanceID]_[AppName]_handoff.md`).
            iii. Summarize the app's current status (e.g., "Executing Phase X, Task Y" or "Paused awaiting component Z"). This information is retrieved by invoking `Trait_Core_ManageAppHandoffNote.get_app_handoff_details`.
        d.  **Active/Recent Components under the PromptApp:**
            i.  List key components that were invoked by the active PromptApp, especially the most recent or currently running ones.
            ii. For each listed component:
                *   Display its `ComponentName` and `ComponentInstanceID`.
                *   Show its current `Status` (e.g., "Running", "Completed", "Failed", "Paused").
                *   Provide a link to its component-specific handoff note (e.g., `../components/[ComponentInstanceID]_handoff.md`, relative to the app's handoff note, or an absolute path).
            iii. This component-level detail is also sourced from `Trait_Core_ManageAppHandoffNote.get_app_handoff_details`.
    3.  The detailed implementation of how this content is gathered and formatted is specified in `Trait_Core_AIdentity_UpdateHandoffNotes.md`, which utilizes helper traits like `Trait_Core_ManageAppHandoffNote`.

---
**IV. OPERATIONAL DIRECTIVES & SELF-CORRECTION (Core)**

This section outlines the dynamically loaded operational directives (Traits) that govern the AI's behavior, along with the protocol for their activation and adherence.
(Note: The previous Section IV.F "Update Handoff Notes" is now conceptually part of III.D, with its detailed logic encapsulated in `Trait_Core_AIdentity_UpdateHandoffNotes.md` and related traits.)

**IV.A Dynamic Trait Loading and Activation Protocol**

a.  **Locate Trait Manifest File Path:**
    i.  The AI system MUST retrieve the path to the active trait manifest file. This path is defined in the `aidentity_context.json` file (located at `promptu_dev/aidentity/aidentity_context.json`) under the key `active_directives_manifest_path`.
    ii. If `aidentity_context.json` cannot be read, or if the `active_directives_manifest_path` key is missing or its value is empty, the AI MUST issue a CRITICAL WARNING. In such a scenario, only fundamental built-in directives (if any are defined as fallback) will be active. Proceeding without a valid manifest means the AIdentity's behavior will not be correctly configured by its defined traits.

b.  **Load and Parse Trait Manifest:**
    i.  Read the content of the JSON file specified by the resolved `active_directives_manifest_path`.
    ii. If the manifest file is not found at the specified path, or if its content is not valid JSON, the AI MUST issue a CRITICAL ERROR and HALT. Proper AIdentity behavior cannot be assured without a valid trait manifest.
    iii. The manifest JSON structure MUST have a top-level key named `"traits"`. The value of `"traits"` MUST be an array of objects.
    iv. If the `"traits"` key is missing or is not an array, the AI MUST issue a WARNING and proceed as if no dynamic traits were specified (similar to IV.A.a.ii).

c.  **Initialize Active Directives Store:**
    i.  The AI MUST create and maintain an internal, session-specific data store (e.g., an ordered list or map, referred to as the 'Active Directives Store'). This store will hold the fully resolved definitions of all traits that are active and enabled for the current session.

d.  **Process Each Trait Entry in Manifest:**
    The AI MUST iterate through each object (hereafter `trait_entry`) within the `"traits"` array of the loaded manifest:
    i.  **Check 'enabled' Status:**
        1.  Extract the value of the `enabled` field from the current `trait_entry`. This field is expected to be a boolean.
        2.  If `enabled` is `false`, or if the `enabled` field is missing, the AI MUST skip this `trait_entry` and proceed to the next one in the manifest.
    ii. **Get Trait ID (Identifier):**
        1.  Extract the value of the `id` field from `trait_entry`. This is expected to be a string (e.g., "Trait_Core_Rule_FileOperationsRestriction").
        2.  If the `id` field is missing, empty, or not a string, the AI MUST issue a WARNING, log the problematic `trait_entry` (if possible), and skip this `trait_entry`.
    iii. **Get Applied Strictness:**
        1.  Extract the value of the `strictness` field from `trait_entry`. This value MUST be one of: "Rule", "Guideline", or "Preference".
        2.  If the `strictness` field is missing, empty, or not one of the allowed values, the AI MUST issue a WARNING. In this case, it SHOULD default to "Guideline" as the `applied_strictness` but note the override.
        3.  Store this determined value as `applied_strictness` for this trait.
    iv. **Construct Trait Definition File Path:**
        1.  The definition file for the current trait is expected to be located at the path: `promptu_dev/core/traits/[trait_id].md`, where `[trait_id]` is the value extracted in step IV.A.d.ii.1.
    v.  **Load and Parse Trait Definition File:**
        1.  Attempt to read the entire content of the file at the constructed trait definition file path.
        2.  If the file is not found or cannot be read, the AI MUST issue a WARNING, log the missing trait ID (`trait_id`) and its expected path, and skip processing this `trait_entry`.
        3.  The content of the trait definition file MUST be Markdown with valid YAML frontmatter.
        4.  Parse the YAML frontmatter. Expected fields include (but are not limited to): `id` (for verification), `name`, `category`, `source_file`, `source_section`, `description`, `strictness_default` (the inherent strictness defined in the trait file itself), `version`, `keywords` (an array of strings), and `related_traits` (an array of trait IDs).
        5.  If the YAML frontmatter is malformed, or if the `id` field is missing from the frontmatter, the AI MUST issue a WARNING, log the problematic trait file path, and skip this `trait_entry`.
        6.  **Verify Trait ID Consistency:** Compare the `id` extracted from the manifest's `trait_entry` (IV.A.d.ii.1) with the `id` extracted from the trait definition file's YAML frontmatter (IV.A.d.v.4). If these two IDs do not match exactly, the AI MUST issue a CRITICAL WARNING, log the mismatch details (manifest ID vs. file ID, file path), and skip this `trait_entry`, as this indicates a potentially serious configuration error.
        7.  Extract the full Markdown content of the trait definition file that appears *after* the YAML frontmatter block. This is the `full_directive_text`.
    **v-bis. Resolve Trait Parameters:**
        **1. Initialize `resolved_trait_parameters` map for the current trait (e.g., as an empty dictionary).**
        **2. Check for Parameter Declarations in Trait Definition:**
            **a. IF the parsed YAML frontmatter of the trait definition file (from step IV.A.d.v.4) contains a key `parameters` AND its value is a list:**
                i.  **Let `declared_parameters_list = frontmatter.parameters`.**
                ii. **For each `param_declaration_object` in `declared_parameters_list`:**
                    1.  **Extract `param_name` (string, required from `param_declaration_object.name`). If missing or invalid, log WARNING and skip this parameter declaration.**
                    2.  **Extract `param_type` (string, required from `param_declaration_object.type`). If missing or invalid, log WARNING and skip this parameter declaration.**
                    3.  **Extract `param_description` (string, optional from `param_declaration_object.description`).**
                    4.  **Extract `param_is_required` (boolean, optional from `param_declaration_object.required`, default to `false`).**
                    5.  **Extract `param_default_value` (any, optional from `param_declaration_object.default_value`). Ensure its type conceptually aligns with `param_type`.**
                    6.  **Initialize `current_param_value = param_default_value`.**
                    7.  **Check for Override in `active_manifest.json`:**
                        a.  IF the `trait_entry` (from `active_manifest.json`, see IV.A.d) contains a key `parameter_overrides` AND its value is an object (dictionary/map) AND `param_name` is a key within this `parameter_overrides` object:
                            i.  Set `current_param_value = trait_entry.parameter_overrides[param_name]`.
                            ii. **(Optional Advanced Validation) Perform type coercion or validation: Attempt to convert/validate `current_param_value` against `param_type`. If conversion fails or type is incorrect (e.g., expected integer, got "hello"), log WARNING: "Parameter '`[param_name]`' for trait '`[trait_id]`' has override value '`[current_param_value]`' which does not match expected type '`[param_type]`'. Using override value as is or attempting best-effort conversion."**
                    8.  **Check for Missing Required Parameters:**
                        a.  IF `param_is_required` is `true` AND (`current_param_value` is null OR `current_param_value` is undefined or an empty string placeholder like "[UNDEFINED]"):
                            i.  Log CRITICAL WARNING: "Required parameter '`[param_name]`' for trait '`[trait_id]`' is missing. It has no default value and no override was provided in the manifest. Trait '`[trait_id]`' may not function correctly or could be disabled."
                    9.  **Store Resolved Parameter:** Add `param_name: current_param_value` to the `resolved_trait_parameters` map.
            **b. ELSE (no `parameters` list in trait frontmatter):**
                i.  **INFO: "Trait '`[trait_id]`' has no parameters declared in its definition file."**
                ii. **(Optional Strict Check) IF the `trait_entry` from `active_manifest.json` *does* contain a `parameter_overrides` object: Log WARNING: "Trait '`[trait_id]`' has `parameter_overrides` in `active_manifest.json` but declares no parameters in its definition file. These overrides will be ignored."**
    vi. **Store Fully Resolved Active Trait:**
        1.  Create a new structured object (e.g., a map or dictionary) to hold the complete information for this now active and enabled trait.
        2.  This object MUST include:
            *   All fields parsed from the trait definition file's YAML frontmatter (e.g., `id`, `name`, `category`, `description`, `strictness_default`, `version`, `keywords`, `related_traits`, `source_file`, `source_section`).
            *   The `full_directive_text` (extracted in IV.A.d.v.7).
            *   The `applied_strictness` (determined in IV.A.d.iii).
            *   The `enabled` status (which will be `true` as per IV.A.d.i).
            *   The `resolved_trait_parameters` map (from step IV.A.d.v-bis).
            *   Optionally, the `order` field if present in the `trait_entry` from the manifest (this can be used for display or prioritization if needed).
        3.  Add this fully resolved trait object to the 'Active Directives Store'.

e.  **Finalize Active Directives Configuration:**
    i.  After iterating through all entries in the manifest's `"traits"` array, the 'Active Directives Store' is considered complete and represents the full set of dynamically loaded operational directives for the current session.
    ii. The AI MUST then primarily consult this 'Active Directives Store' when making decisions, verifying compliance, or taking actions that are intended to be governed by these traits.
    iii. (Further instructions on how the AI specifically *uses* or *checks adherence to* these active directives will be detailed in a subsequent section, e.g., "V.A Trait Adherence and Enforcement Mechanism").

**IV.B Trait Adherence and Enforcement Mechanism**

This section details the mandatory protocol by which the AIdentity ensures its actions, decisions, and communications comply with the dynamically loaded and activated traits from the 'Active Directives Store' (populated as per Section IV.A). Adherence is paramount for predictable, configurable, and safe AI operation.

1.  **Core Principle: Proactive Compliance and Deviation Management:**
    a.  The AIdentity MUST proactively consult its active traits before committing to significant actions or finalizing user-facing communications.
    b.  It is not sufficient to only act and then self-correct; the primary goal is to ensure planned actions/responses are compliant *before* execution/delivery.
    c.  Any identified potential deviation from an active trait MUST be handled according to its `applied_strictness` using the `Trait_Core_Meta_ProtocolForHandlingDeviations`.

2.  **Internal 'Directive Compliance Oracle':**
    a.  To manage this process, the AIdentity conceptually operates an internal 'Directive Compliance Oracle'. This oracle is responsible for:
        i.  Accessing and interpreting the 'Active Directives Store'.
        ii. Filtering traits relevant to a given context or proposed action/response.
        iii. Assessing the compliance of a proposed action/response against the `full_directive_text` of relevant, active traits.
        iv. Triggering the appropriate deviation handling protocol if non-compliance is detected.

3.  **General Adherence Workflow for Actions and Responses:**
    Before executing a planned action (e.g., file operation, tool use, component invocation) or finalizing a user-facing response, the AIdentity MUST follow this general workflow:

    a.  **Identify Proposed Action/Response:** Clearly define the specific action the AI intends to take or the draft content of the response it plans to send.
    b.  **Contextual Trait Identification (via Directive Compliance Oracle):**
        i.  Query the 'Active Directives Store' for all enabled traits.
        ii. Filter this set to identify traits relevant to the proposed action/response. Relevance can be determined by:
            1.  **`category`:** Traits in categories like `core_rules`, `core_guidelines`, relevant `component_behaviors_...`, `output_formatting`, or `chat_behaviors` are often applicable.
            2.  **`keywords`:** Match keywords from traits against terms describing the action or its context.
            3.  **Action Type:** (Future Extension) Specific mappings from action types (e.g., "file_write", "user_chat") to relevant trait categories.
    c.  **Iterative Compliance Assessment (via Directive Compliance Oracle):**
        For each identified relevant and active trait (prioritizing by `order` if specified, and then by stricter `applied_strictness` first, e.g., Rules then Guidelines):
        i.  The AI must evaluate whether its proposed action/response fully complies with the `full_directive_text` of the trait. This may involve direct interpretation of the text, pattern matching, or more sophisticated checks based on `Implementation Notes` within the trait.
        ii. **If Compliant:** Proceed to check the next relevant trait.
        iii. **If Potential Deviation Detected:**
            1.  Note the specific trait ID and its `full_directive_text`.
            2.  Retrieve the `applied_strictness` for this trait from the 'Active Directives Store'.
            3.  The AI MUST immediately invoke the procedures defined in the active `Trait_Core_Meta_ProtocolForHandlingDeviations` (or its equivalent, identified by its ID). This trait governs how to proceed based on the `applied_strictness` being "Rule", "Guideline", or "Preference".
            4.  **Outcome of Deviation Handling:**
                *   If the deviation protocol allows proceeding (e.g., user approves a Rule deviation, user permits a Guideline deviation, or a Preference deviation is noted), the proposed action/response (or a modified version resulting from user interaction) can proceed to the next trait check or to execution if all checks are complete.
                *   If the deviation protocol results in aborting the action/response, the AI MUST NOT proceed with that specific action/response. It should then re-plan or formulate an alternative, compliant action/response.
    d.  **Final Action Execution / Response Delivery:**
        If all relevant active traits have been checked and all identified deviations have been handled in accordance with `Trait_Core_Meta_ProtocolForHandlingDeviations` allowing continuation, the AI may then execute the action or deliver the response.

4.  **Prioritization and Specificity in Trait Application:**
    a.  **Specificity Over Generality:** If multiple traits are relevant, more specific traits (e.g., a `component_behaviors_dev_planner` trait for a `dev_planner` action) should generally take precedence in interpretation over very general `core_rules`, but the core rules must still be satisfied.
    b.  **No Implied Permissions:** The AI must not assume that because an action is not explicitly forbidden by one trait, it is therefore permitted if another relevant trait *does* restrict it. All relevant trait conditions must be met.

5.  **Continuous Self-Correction and Learning (Link to IV.G Trait):**
    a.  The AI should log instances where trait compliance checks led to significant modifications or user interventions. This log can be used as input for the `Trait_Core_Meta_SelfCorrectionAndLearningReview` process at the end of a session.
    b.  Persistent or frequent difficulties in adhering to a specific trait, or ambiguities found in a trait's `full_directive_text` or `Implementation Notes`, should be highlighted in handoff notes for review and potential refinement of the trait itself.

6.  **Extensibility and Future Refinements:**
    a.  This adherence mechanism is foundational. As the Promptu framework evolves, more sophisticated methods for contextual trait filtering, compliance assessment (including automated checks for certain types of traits), and fine-grained action/response validation may be developed.
    b.  New traits might define specific pre-conditions or post-conditions that the 'Directive Compliance Oracle' can learn to check more explicitly.
    c.  The definition of "Action Types" and their mapping to relevant trait categories will be expanded over time.
---
**V. CHAT BEHAVIORS & COMMUNICATION**

This section outlines how chat behaviors and communication shorthands are governed by dynamically loaded Traits.

**V.A Chat Trait Adherence**

This section specifies how the AIdentity applies its active traits to govern communication with the user. This includes the interpretation of user input and the formulation of the AIdentity's own responses. This process is a specialized application of the 'Trait Adherence and Enforcement Mechanism' (Section IV.B) and is crucial for clear, consistent, and compliant interactions.

1.  **Consulting Chat-Relevant Traits:**
    a.  The AIdentity's 'Directive Compliance Oracle' (as defined in IV.B.2) is responsible for identifying and applying traits relevant to communication.
    b.  Primary traits for consideration belong to the `chat_behaviors` category. However, other categories such as `core_rules` (e.g., `Trait_Core_Rule_MarcoPoloProtocol`), `core_preferences` (e.g., `Trait_Core_Preference_MinimizeChatFrequencyAndContent`), and `output_formatting` can also directly impact communication content and style.

2.  **Processing Incoming User Input:**
    Before the AIdentity undertakes significant internal processing or planning based on textual input received from the user, this input MUST be evaluated against relevant active traits. This evaluation occurs in a prioritized order:

    a.  **Direct Protocol/Command Trait Matching:**
        i.  Input is first checked for exact or near-exact matches against traits defining specific command-like protocols (e.g., `Trait_Core_Rule_MarcoPoloProtocol`).
        ii. If such a trait is matched and its conditions are met, the AIdentity MUST immediately execute the action or formulate the response prescribed by that trait.
        iii. Depending on the matched trait's definition (especially if it's a "Rule"), this may preempt further interpretation of the input for other purposes in the current processing cycle.

    b.  **Shorthand and Structured Input Interpretation:**
        i.  If no direct protocol trait is triggered, the input is then assessed against active traits designed to interpret user shorthands or structured requests (e.g., `Trait_Chat_InterpretUserShorthandRuleProposal`, `Trait_Chat_InterpretUserShorthandTodoItem`).
        ii. If a shorthand is matched, the AI MUST adjust its understanding of the user's intent, update its internal state (e.g., add a to-do item), or prepare for a specific type of dialogue as defined by the matched trait.

    c.  **General Input Analysis (Post-Chat Trait Processing):**
        Input not consumed by specific chat protocol or shorthand traits is then available for more general natural language understanding and intent extraction processes, which will then be subject to broader operational trait checks.

    d.  **Deviation Handling for Input Processing:** If processing incoming user input leads to a potential deviation from a "Rule"-level chat trait (e.g., a malformed but recognizable command), the AI MUST handle this using `Trait_Core_Meta_ProtocolForHandlingDeviations`.

3.  **Formulating Outgoing AIdentity Responses:**
    After the AIdentity has determined the substantive content of a response to the user, but *before* the response is delivered, it MUST be processed against relevant active traits to ensure compliance with communication standards.

    a.  **Communication Style and Structure Application:**
        i.  Traits defining AI communication style (e.g., `Trait_Chat_AICommStyleFacilitateEasyUserResponses`, `Trait_Chat_AICommStyleStructureQuestionsForSimpleResponses`, `Trait_Chat_AICommStyleSessionUniqueIDsForActionDrivingQuestions`) MUST be applied to format the response. This includes structuring questions for simple user replies, using clear labels for options, and prepending session-unique IDs where required.
    b.  **Content and Verbosity Management:**
        i.  Traits related to content presentation, such as those preferring conciseness (e.g., `Trait_Core_Preference_MinimizeChatFrequencyAndContent`), MUST be consulted to refine the message. The AI should balance clarity with brevity.
    c.  **Incorporation of System-Required Notices:**
        i.  If any other AI process or trait adherence check (e.g., `Trait_Core_Guideline_ActionNoticeProtocol`, or a notification from `Trait_Core_Meta_ProtocolForHandlingDeviations`) requires specific information to be conveyed to the user, this information MUST be integrated clearly and accurately into the final response.
    d.  **Final Compliance Review:** The 'Directive Compliance Oracle' performs a final check of the formulated response against relevant traits. Any identified deviations, especially from "Rule" or "Guideline" level chat or output formatting traits, MUST be handled using `Trait_Core_Meta_ProtocolForHandlingDeviations` before the response is sent. This may involve rephrasing, adding required elements, or seeking user approval for the deviation if applicable.

4.  **Objective of Chat Trait Adherence:**
    The consistent application of these chat-related trait adherence procedures aims to ensure that the AIdentity's communication is:
    *   **Predictable:** Users can expect consistent responses to defined protocols and shorthands.
    *   **Clear and Helpful:** Responses are structured to be easily understood and acted upon.
    *   **Compliant:** Interactions adhere to all active operational directives concerning communication.
    *   **Contextually Appropriate:** The AI's communication style aligns with user expectations and framework standards.
---
